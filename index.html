<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>p5 Whiteboard</title>

  <!-- p5 -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

  <!-- jsPDF (for PDF export) -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <!-- canvg (render MathJax SVG to canvas without tainting) -->
  <script src="https://cdn.jsdelivr.net/npm/canvg@3.0.10/lib/umd.min.js"></script>

  <!-- MathJax v2 (SVG output) with Gyre-Termes -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      showProcessingMessages: false,
      messageStyle: "none",
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      SVG: {
        font: "Gyre-Termes",
        linebreaks: { automatic: true }
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_SVG"></script>

  <style>
    @font-face{
      font-family:"Libertinus Sans";
      src:url("https://cdn.jsdelivr.net/gh/faraphys/fonts@main/LibertinusSans-Regular.woff2") format("woff2");
      font-style:normal; font-weight:400; font-display:swap;
    }
    @font-face{
      font-family:"Libertinus Sans";
      src:url("https://cdn.jsdelivr.net/gh/faraphys/fonts@main/LibertinusSans-Bold.woff2") format("woff2");
      font-style:normal; font-weight:700; font-display:swap;
    }
    @font-face{
      font-family:"Libertinus Sans";
      src:url("https://cdn.jsdelivr.net/gh/faraphys/fonts@main/LibertinusSans-Italic.woff2") format("woff2");
      font-style:italic; font-weight:400; font-display:swap;
    }

    :root{
      --panel: rgba(255,255,255,0.92);
      --border: rgba(0,0,0,0.12);
      --text: rgba(0,0,0,0.86);
      --shadow: 0 6px 18px rgba(0,0,0,0.10);
      --radius: 12px;
      --font: "Libertinus Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --outline: rgba(140,140,140,0.22);

      --grid-a: 9;
      --dots-a: 34;
      --dots-r: 2.4;
    }

    html, body{ margin:0; height:100%; background:transparent; font-family:var(--font); color:var(--text); overflow:hidden; }
    #stage{ position:fixed; inset:0; z-index:1; transform-origin: 50% 50%; }
    #canvas-wrap{ position:absolute; inset:0; z-index:1; background:transparent; }
    #canvas-outline{ position:absolute; inset:0; border:1px solid var(--outline); pointer-events:none; z-index:2; }

    #text-overlay{ position:absolute; inset:0; z-index:5; pointer-events:none; transform-origin: 0 0; }
    .text-box{
      position:absolute;
      transform-origin: top left;
      pointer-events:none;
      white-space: pre-wrap;
      color:var(--text);
      font-family: var(--font);
      cursor: default;
      user-select: none;
    }
    .text-box.draggable{ cursor: grab; pointer-events:auto; }
    .text-box.dragging{ cursor: grabbing; }

    /* small HUD boxes (measure + toast + shortcuts) */
    .hudBox{
      position:fixed;
      z-index:999999;
      padding:6px 8px;
      border-radius:10px;
      background:rgba(0,0,0,0.78);
      color:white;
      font-size:12px;
      pointer-events:none;
      opacity:0;
      transform: translateY(6px);
      transition: opacity 120ms ease, transform 120ms ease;
      white-space:nowrap;
      line-height: 1.25;
    }
    .hudBox.show{ opacity:1; transform: translateY(0); }

    #cursorHint{
      position:fixed; z-index:999999;
      padding:6px 8px;
      border-radius:10px;
      background:rgba(0,0,0,0.78);
      color:white;
      font-size:12px;
      pointer-events:none;
      opacity:0; transform: translateY(6px);
      transition: opacity 120ms ease, transform 120ms ease;
      white-space:nowrap;
    }
    #cursorHint.show{ opacity:1; transform: translateY(0); }

    /* toolbar */
    #ui{
      position:fixed; top:10px; right:10px; z-index:10;
      display:flex; flex-direction:column; align-items:stretch;
      gap:6px;
      background:rgba(245,245,245,0.94); border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:8px;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      user-select:none;
      width:146px;
      max-width: calc(100vw - 20px); box-sizing:border-box;
      max-height: calc(100vh - 20px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    #ui.collapsed .utilRow, #ui.collapsed .exportRow, #ui.collapsed .core, #ui.collapsed .advanced{ display:none !important; }

    .core, .advanced{ display:flex; flex-direction:column; gap:6px; }
    #dragHandle{
      display:flex; align-items:center; justify-content:space-between; gap:6px;
      padding:6px 6px; border:1px solid var(--border); border-radius:10px; background:rgba(255,255,255,0.88);
      cursor:grab; touch-action:none;
    }
    #dragHandle:active{ cursor:grabbing; }

    .dots{ display:grid; grid-template-columns: repeat(3, 4px); grid-auto-rows:4px; gap:3px; opacity:0.55; }
    .dots span{ width:4px; height:4px; border-radius:50%; background:rgba(0,0,0,0.55); display:block; }

    .handleBtns{ display:flex; gap:4px; align-items:center; }

    .miniBtn{
      width:26px; height:26px; display:inline-flex; align-items:center; justify-content:center;
      border:1px solid var(--border); border-radius:999px; background:rgba(245,245,245,0.95); cursor:pointer;
      font-size:13px; line-height:1; padding:0; color:var(--text);
    }
    /* Keep circular buttons in the util/export rows white */
    .utilRow .miniBtn, .exportRow .miniBtn{ background:rgba(255,255,255,0.95); }
    .miniBtn.active{ outline:2px solid rgba(0,0,0,0.22); }
    #btnCycle{ font-size:16px; }
    #glyphCycle{ font-size:18px; line-height:1; display:inline-block; transform: translateY(-1px); }

    
    .utilRow{ display:flex; gap:6px; justify-content:space-between; }
    .utilRow .utilBtn{ flex:1; width:auto; font-size:14px; }
.exportRow{ display:flex; gap:6px; justify-content:space-between; }
    .exportRow .exportBtn{ flex:1; width:auto; font-size:14px; }

    .shortcutWrap{ position:relative; }
    #shortcutCard{
      position:absolute; top:110%; right:0;
      background:rgba(255,255,255,0.96);
      border:1px solid var(--border);
      border-radius:12px; box-shadow:var(--shadow);
      padding:10px 10px;
      width:260px;
      display:none;
      z-index:99999;
      color:rgba(0,0,0,0.86);
      font-family: var(--font);
    }
    .shortcutWrap:hover #shortcutCard{ display:none; }
    #shortcutCard .title{ font-size:12px; font-weight:700; margin-bottom:6px; }
    #shortcutCard .row{ font-size:12px; display:flex; justify-content:space-between; gap:10px; opacity:0.88; }
    #shortcutCard .row code{
      background:rgba(0,0,0,0.06); padding:1px 6px; border-radius:7px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      color:inherit;
    }

    .tool, button.action{
      border:1px solid var(--border);
      background:rgba(255,255,255,0.88);
      color:var(--text);
      border-radius:999px; padding:7px 10px; font-size:12px; cursor:pointer;
      width:100%; box-sizing:border-box;
      display:flex; align-items:center; gap:8px; justify-content:flex-start;
      font-family: var(--font);
    }
    button.action{ border-radius:12px; padding:8px 10px; }
    .tool .ico, button.action .ico{ width:16px; text-align:center; opacity:0.90; }
    .tool.active{ background:rgba(0,0,0,0.92); border-color:rgba(0,0,0,0.92); color:white; }
    .ico.red{ color:#D7263D; opacity:1; }

    select{
      border:1px solid var(--border);
      border-radius:999px;
      padding:7px 10px;
      background:rgba(255,255,255,0.88);
      font-size:12px; cursor:pointer; width:100%; box-sizing:border-box;
      text-align:left; color:var(--text);
      font-family: var(--font);
    }
    select option{ text-align:left; }

    .pill{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border); border-radius:999px; padding:7px 10px;
      background:rgba(255,255,255,0.88); font-size:12px; cursor:pointer; white-space:nowrap;
      width:100%; box-sizing:border-box; justify-content:flex-start;
      color:var(--text);
      font-family: var(--font);
    }
    .pill input{ margin:0; }

    .color-select{
      position:relative; display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid var(--border); border-radius:999px; padding:6px 10px; background:rgba(255,255,255,0.88); cursor:pointer;
      width:100%; box-sizing:border-box;
      color:var(--text);
      font-family: var(--font);
    }
    .color-left{ display:flex; align-items:center; gap:8px; min-width:0; }
    .chip{ width:16px; height:16px; border-radius:4px; border:1px solid rgba(0,0,0,0.18); box-sizing:border-box; background:#111; }
    .caret{ opacity:.7; font-size:12px; flex:0 0 auto; }

    /* Popups must not be clipped by the scrollable toolbar */
    .palette{
      position:fixed;
      top:0; left:0;
      padding:8px;
      background:rgba(255,255,255,0.98);
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:var(--shadow);
      display:none;
      z-index:99999;
      transform-origin: top right;
    }
    .palette.open{ display:block; }
    .palette-grid{ display:grid; grid-template-columns: repeat(6, 18px); gap:8px; }
    .swatch{ width:18px; height:18px; border-radius:4px; border:1px solid rgba(0,0,0,0.18); cursor:pointer; box-sizing:border-box; }

    .layers-select{
      position:relative; display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid var(--border); border-radius:999px; padding:6px 10px; background:rgba(255,255,255,0.88); cursor:pointer;
      width:100%; box-sizing:border-box;
      color:var(--text);
      font-family: var(--font);
    }

    .layers-menu{
      position:fixed;
      top:0; left:0;
      padding:6px;
      background:rgba(255,255,255,0.98);
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:var(--shadow);
      display:none;
      z-index:99999;
      min-width:190px;
      transform-origin: top right;
      font-family: var(--font);
    }
    .layers-menu.open{ display:block; }

    .layer-item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px; border-radius:10px; cursor:pointer; font-size:12px; user-select:none;
    }
    .layer-item:hover{ background:rgba(0,0,0,0.04); }
    .layer-left{ display:flex; align-items:center; gap:10px; min-width:0; }
    .tick{ width:16px; text-align:center; opacity:0.9; font-weight:700; }
    .layer-name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .vis-dot{ width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,0.22); background:rgba(0,0,0,0.10); }
    .layer-item.invisible .layer-name{ opacity:0.45; text-decoration: line-through; }
    .layer-item.invisible .vis-dot{ opacity:0.25; }

    #textEditor{
      position:fixed; z-index:99999; display:none;
      min-width:280px; max-width:min(560px, calc(100vw - 24px));
      background:rgba(255,255,255,0.97);
      border:1px solid rgba(0,0,0,0.22);
      border-radius:12px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.14);
      padding:10px;
      color:rgba(0,0,0,0.86);
      font-family: var(--font);
    }
    #textEditorTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    #textEditorTitle{ font-size:12px; font-weight:700; opacity:0.85; }
    #textEditorTop select{ width:auto; padding:6px 10px; }
    #textEditor textarea{
      width:100%;
      border:1px solid rgba(0,0,0,0.16);
      border-radius:10px;
      padding:10px;
      resize:both;
      min-height:54px;
      font-family: var(--font);
      font-size: 14px;
      outline:none;
      box-sizing:border-box;
      background:white;
      color:rgba(0,0,0,0.86);
    }
    #textHint{ margin-top:8px; font-size:11px; opacity:0.65; display:flex; justify-content:space-between; align-items:center; gap:10px; }
    #textOkBtn{
      border:1px solid rgba(0,0,0,0.16);
      background:rgba(255,255,255,0.92);
      border-radius:10px;
      padding:6px 10px;
      font-size:12px;
      cursor:pointer;
      font-family: var(--font);
      color:rgba(0,0,0,0.86);
      white-space:nowrap;
    }
    #textOkBtn:hover{ background:rgba(0,0,0,0.05); }

    #ui, #ui * { touch-action: none; }

    /* Hide visible scrollbar (still scrollable via touch-drag) */
    #ui{ scrollbar-width: none; }
    #ui::-webkit-scrollbar{ width:0; height:0; }

    /* Cursor hint color chip */
    .hintChip{
      display:inline-block;
      width:10px; height:10px;
      border-radius:3px;
      margin-left:8px;
      border:1px solid rgba(255,255,255,0.45);
      vertical-align:middle;
    }

    /* Shortcut box (toggle, left of toolbar) */
    #shortcutBox{
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 10px;
      pointer-events:none;
      white-space: normal;
      max-width: 280px;
      line-height: 1.25;
    }
    #shortcutBox .title{ font-weight:700; margin-bottom:6px; }
    #shortcutBox .row{ display:flex; justify-content:space-between; gap:10px; white-space:nowrap; }
    #shortcutBox .row span{ overflow:hidden; text-overflow:ellipsis; }
    #shortcutBox .row code{
      background:rgba(255,255,255,0.14);
      padding:1px 6px;
      border-radius:7px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
    }

    #shortcutBox.show{ pointer-events:auto; }

    /* Disable hover-card behavior (we use click-toggle box instead) */
    .shortcutWrap:hover #shortcutCard{ display:none; }

  </style>
</head>

<body>
  <div id="ui" class="collapsed">
    <div id="dragHandle" title="Drag toolbar">
      <div class="dots" aria-hidden="true">
        <span></span><span></span><span></span>
        <span></span><span></span><span></span>
      </div>

      <div class="handleBtns">
        <button id="btnPointer" class="miniBtn" title="Pointer (Esc)">üñ±Ô∏è</button>
        <button id="btnShortcuts" class="miniBtn" title="Toggle shortcut list (K)">‚å®</button>

        <button id="btnCycle" class="miniBtn" title="Expand/collapse toolbar (X)"><span id="glyphCycle">‚ñæ</span></button>
      </div>
    </div>

    
    <!-- Utility row (collapsed) -->
    <div id="utilRow" class="utilRow" aria-label="Shortcuts / Zoom">
      <button id="btnPan" class="miniBtn utilBtn" title="Move canvas (M)">üñêÔ∏é</button>
      <button id="btnZoomOut" class="miniBtn utilBtn" title="Zoom out (U)">‚àí</button>
      <button id="btnZoomIn" class="miniBtn utilBtn" title="Zoom in (Z)">+</button>
      <button id="btnZoomReset" class="miniBtn utilBtn" title="Reset view (R)">‚Ü∫</button>
    </div>
<!-- Export row (hidden when embedded) -->
    <div id="exportRow" class="exportRow" aria-label="Export / Save / Load">
      <button class="miniBtn exportBtn" id="btnPNG" title="Copy PNG to clipboard (Ctrl+P)">üì∑</button>
            <button class="miniBtn exportBtn" id="btnPDF" title="Export PDF (Ctrl+F)">‚§ì</button>
<button class="miniBtn exportBtn" id="btnSave" title="Save all annotations to JSON (Ctrl+S)">üíæ</button>
      <button class="miniBtn exportBtn" id="btnOpen" title="Load annotations from JSON (Ctrl+O)">üìÇ</button>
    </div>

    <!-- CORE -->
    <div class="core">
      <button class="tool" id="toolPen" title="Pen (P)"><span class="ico">‚úé</span><span>Pen</span></button>
      <button class="tool" id="toolEraser" title="Eraser (E)"><span class="ico">üßΩ</span><span>Eraser</span></button>
      <button class="tool" id="toolHighlighter" title="Highlighter (H)"><span class="ico">üñçÔ∏è</span><span>Highlighter</span></button>

      <select id="shapeTool" title="Shapes (S)">
        <option value="line">‚Äî  Line</option>
        <option value="arrow" selected>‚Üí  Arrow</option>
        <option value="circle">‚óØ  Circle</option>
        <option value="rect">‚ñ≠  Rect</option>
        <option value="shadowRect">‚ñ≠  Shadow frame</option>
        <option value="rightTri">‚óø  Right triangle</option>
        <option value="coord1">‚àü  Coord. system 1</option>
        <option value="coord2">‚ä¢  Coord. system 2</option>
        <option value="coord3">‚úõ  Coord. system 3</option>
        <option value="ellipse">‚¨≠  Ellipse (e=0.9)</option>
        <option value="ellipse99">‚¨≠  Ellipse (e=0.99)</option>
      </select>

      <div class="color-select" id="colorSelect" title="Color (Ctrl+1..9, C)">
        <div class="color-left">
          <div class="chip" id="colorChip"></div>
          <div style="font-size:12px; opacity:.85;">üé®  Color</div>
        </div>
        <div class="caret">‚ñæ</div>
        <div class="palette" id="palette">
          <div class="palette-grid" id="paletteGrid"></div>
        </div>
      </div>
    </div>

    <!-- ADVANCED -->
    <div class="advanced">
      <select id="strokeWidth" title="Width (1..9, W)"></select>
      <select id="smoothing" title="Smoothness (A)"></select>
      <select id="transp" title="Transp. (Q)"></select>

      <button class="tool" id="toolFill" title="Fill (F)"><span class="ico">ü™£</span><span>Fill</span></button>
      <button class="tool" id="toolText" title="Text / LaTeX (T)"><span class="ico">T</span><span>Text / LaTeX</span></button>

      <button class="tool" id="toolLaser" title="Laser (O)"><span class="ico red">‚óé</span><span>Laser</span></button>
      <button class="tool" id="toolLasso" title="Lasso (L)"><span class="ico">‚ü≤</span><span>Lasso</span></button>

      <select id="bgMode" title="Background (G)">
        <option value="transparent" selected>‚ñ¶  Bg: transp.</option>
        <option value="dots">‚Ä¢  Bg: dots</option>
        <option value="grid">‚ßâ  Bg: grid</option>
      </select>

      <label class="pill" title="Snap (N)">
        <input id="snap" type="checkbox" />
        ‚åó  Snap
      </label>

      <div class="layers-select" id="layersSelect" title="Layers (Y)">
        <div style="font-size:12px; opacity:.85;" id="layersLabel">üß±  Layers</div>
        <div class="caret">‚ñæ</div>
        <div class="layers-menu" id="layersMenu"></div>
      </div>

      <button class="action" id="undo" title="Undo (Ctrl+Z)"><span class="ico">‚Ü∂</span><span>Undo</span></button>
      <button class="action" id="clear" title="Clear (Ctrl+D)"><span class="ico">üóë</span><span>Clear</span></button>
    </div>
</div>
<div id="textEditor">
    <div id="textEditorTop">
      <div id="textEditorTitle">Enter text (LaTeX supported)</div>

      <select id="textStyleEditor" title="Font style">
        <option value="regular" selected>Regular</option>
        <option value="bold">Bold</option>
        <option value="italic">Italic</option>
      </select>

      <select id="textSizeEditor" title="Font size">
        <option value="10">10 pt</option>
        <option value="12">12 pt</option>
        <option value="14">14 pt</option>
        <option value="16">16 pt</option>
        <option value="20" selected>20 pt</option>
        <option value="24">24 pt</option>
        <option value="28">28 pt</option>
        <option value="36">36 pt</option>
        <option value="48">48 pt</option>
        <option value="72">72 pt</option>
      </select>
    </div>
    <textarea id="textInput" spellcheck="false"></textarea>
    <div id="textHint">
      <span>e.g. <code>velocity $v_x$</code>. Ctrl+Enter or OK. Esc = cancel.</span>
      <button id="textOkBtn" type="button">OK</button>
    </div>
  </div>

  <div id="stage">
  <div id="canvas-wrap"></div>
  <div id="canvas-outline"></div>
  <div id="text-overlay"></div>
</div>
  <div id="cursorHint"></div>

  <!-- HUD boxes -->
  <div id="measureBox" class="hudBox"></div>
  <div id="toastBox" class="hudBox"></div>
  <div id="shortcutBox" class="hudBox"></div>

<script>
/* =====================
   Embedded detection
   ===================== */
const EMBEDDED = (() => {
  try { return window.self !== window.top; } catch(e){ return true; }
})();

/* =====================
   Config / state
   ===================== */
const GRID_STEP = 20;

// Laser fade
const LASER_FADE_MS = 2000;

// Hold alignment
const HOLD_ALIGN_MS = 500;
const STILL_EPS_PX = 7;
const STILL_TIME_MS = 120;

// Free-draw-to-line conversion
const FREE_LINE_MAX_DEVIATION = 7;
const FREE_LINE_MIN_LENGTH = 18;

// ellipse eccentricity 0.9
const ELLIPSE_E = 0.9;
const ELLIPSE_MINOR_RATIO = Math.sqrt(1 - ELLIPSE_E*ELLIPSE_E);

const COLORS = [
  "#111111", "#D7263D", "#009E73", "#0072B2", "#FFFFFF", "#FF8A00",
  "#E69F00", "#F0E442", "#56B4E9", "#CC79A7", "#00BFC4", "#D55E00",
  "#FFFF00", "#39FF14", "#FF00FF", "#00FFFF", "#B026FF", "#FF1744"
];

/* =====================
   Persistence (per slide)
   ===================== */
const STORAGE_PREFIX = "p5wb:v2:";
let slideKey = "";
let lastSlideKey = "";

function safeParseJSON(s, fallback){
  try{ return JSON.parse(s); } catch(e){ return fallback; }
}

function normalizedPresentationURL(){
  const u = new URL(window.location.href);
  return u.origin + u.pathname;
}

function getDeckKey(){
  const u = new URL(window.location.href);
  const deck = u.searchParams.get("deck") || u.searchParams.get("deckId") || u.searchParams.get("id");
  const p = (u.pathname || "").replace(/\/+$/,"");
  return (deck || p || "deck").slice(0,200);
}

function getSlideKeyFromURL(){
  const u = new URL(window.location.href);
  const sp = u.searchParams;
  const cand =
    sp.get("slide") || sp.get("s") ||
    (sp.get("h")!=null && sp.get("v")!=null ? `h${sp.get("h")}-v${sp.get("v")}` : "") ||
    sp.get("index") || sp.get("page") || sp.get("p");
  if (cand) return String(cand);

  const h = (u.hash || "").replace(/^#/,"").trim();
  if (h) return h;

  return (u.pathname + u.search + u.hash).slice(0,240) || "slide";
}

function storageKeyFor(slKey){
  return STORAGE_PREFIX + getDeckKey() + ":" + slKey;
}

function exportState(){
  return {
    v: 2,
    ts: Date.now(),
    bgMode,
    activeLayer,
    layers: layers.map(L => ({
      visible: !!L.visible,
      actions: L.actions || []
    }))
  };
}

function importState(state){
  if (!state || !state.layers || !Array.isArray(state.layers)) return false;

  bgMode = state.bgMode || "transparent";
  if (bgModeSel) bgModeSel.value = bgMode;

  activeLayer = clamp(parseInt(state.activeLayer ?? 0, 10) || 0, 0, 2);

  for (let i=0;i<3;i++){
    const src = state.layers[i] || {visible:true, actions:[]};
    layers[i].visible = (typeof src.visible === "boolean") ? src.visible : true;
    layers[i].actions = Array.isArray(src.actions) ? src.actions : [];
  }

  clearSelection();
  rebuildAllBuffers();
  rebuildTextOverlay();
  updateLayersLabel();
  rebuildLayersMenu();
  return true;
}

function saveToStorage(forKey){
  if (!layers || !layers.length) return;
  try{
    const k = storageKeyFor(forKey || slideKey);
    localStorage.setItem(k, JSON.stringify(exportState()));
  } catch(e){}
}

function loadFromStorage(forKey){
  const k = storageKeyFor(forKey || slideKey);
  const raw = localStorage.getItem(k);
  if (!raw) return false;
  const state = safeParseJSON(raw, null);
  return importState(state);
}

/* =====================
   Optional postMessage hook
   ===================== */
window.addEventListener("message", (ev)=>{
  const d = ev.data;
  if (!d || typeof d !== "object") return;

  if (d.type === "whiteboard:setSlide"){
    let k = d.key;
    if (!k && (d.h!=null || d.v!=null)) k = `h${d.h ?? 0}-v${d.v ?? 0}`;
    if (!k) return;

    k = String(k);
    if (k !== slideKey){
      saveToStorage(slideKey);
      slideKey = k;
      lastSlideKey = k;
      for (let i=0;i<3;i++){ layers[i].actions=[]; layers[i].visible=true; layers[i].pg.clear(); }
      loadFromStorage(slideKey);
      rebuildAllBuffers();
      rebuildTextOverlay();
    }
  }

  if (d.type === "whiteboard:save") saveToStorage(slideKey);
  if (d.type === "whiteboard:clear"){
    for (let i=0;i<3;i++){ layers[i].actions=[]; layers[i].visible=true; layers[i].pg.clear(); }
    rebuildAllBuffers();
    rebuildTextOverlay();
    saveToStorage(slideKey);
  }
});

/* =====================
   Tools / UI state
   ===================== */
let tool = "pointer";
let strokeWidth = 1;
let smoothing = 2;
let transp = 1; // 1..10
let currentColor = COLORS[0];
let snapToGrid = false;
let bgMode = "transparent";

// View transform (pan/zoom) feature removed for robustness across browsers.
// Coordinates are screen pixels (0..width, 0..height).
let view = { tx: 0, ty: 0, scale: 1 }; // kept for backwards compatibility (unused)

// Simple UI zoom (scales the drawing stage only)
let zoomLevel = 1;
function resetView(){
  // Reset zoom + undo any panning back to original position
  zoomLevel = 1;
  applyZoom();
  if (panOffsetTotal.x || panOffsetTotal.y){
    const dx = -panOffsetTotal.x;
    const dy = -panOffsetTotal.y;
    for (let li=0; li<3; li++){
      for (const a of layers[li].actions) translateAction(a, dx, dy);
    }
    panOffsetTotal = {x:0, y:0};
    rebuildAllBuffers();
    rebuildTextOverlay();
    saveToStorage(slideKey);
  }
  showToast("Reset view", 900);
}

function applyZoom(){
  const st = document.getElementById("stage");
  if (!st) return;
  st.style.transform = `scale(${zoomLevel})`;
}

function screenToWorld(sx, sy){ return { x: sx, y: sy }; }
function worldToScreen(wx, wy){ return { x: wx, y: wy }; }
function updateOverlayTransforms(){ /* no-op */ }

let lastNonEraserWidth = 1;
let current = null;
let laserTrail = [];

let pointerDown=false, activePointerId=null, activePointerType="mouse", lastPressure=1;

let isShiftDown = false;

const textOverlay = document.getElementById("text-overlay");
const cursorHint = document.getElementById("cursorHint");
const measureBox = document.getElementById("measureBox");
const toastBox = document.getElementById("toastBox");
const shortcutBox = document.getElementById("shortcutBox");
let lastPointerClient = {x: 0, y: 0};
let suppressCanvasUntil = 0; // used to avoid stray canvas actions after UI interactions

// remember pen/shapes values before highlighter/laser
let penState = { color: currentColor, width: strokeWidth, transp, smoothing };

// laser: first-time defaults but then let user change freely
let laserEverUsed = false;
let laserPrefs = { color:"#D7263D", width:2, transp:7 };

// text tool
let defaultTextSize = 20;
let defaultTextStyle = "regular"; // regular|bold|italic
const textEditor = document.getElementById("textEditor");
const textInput  = document.getElementById("textInput");
const textOkBtn  = document.getElementById("textOkBtn");
const textSizeEditor = document.getElementById("textSizeEditor");
const textStyleEditor = document.getElementById("textStyleEditor");
let textDraft = null;

// Hold alignment timers
let holdAlignTimer = null;
let lastSignificantMoveAt = 0;
let lastMovePos = {x:0,y:0};

// Shapes cycling (S)
const SHAPES = [ "line", "arrow", "circle", "rect", "shadowRect", "rightTri", "titleBox", "coord1", "coord2", "coord3", "ellipse", "ellipse99" ];
let shapeIndex = 1; // arrow

// Layers (3)
let layers = [];
let activeLayer = 0;
let undoStack = Array.from({length:3}, () => []);
const UNDO_LIMIT = 40;

/* =====================
   Lasso (move + delete only)
   ===================== */

// Pan (preview translate, applied on release)
let panState = { active:false, start:{x:0,y:0}, last:{x:0,y:0}, dx:0, dy:0 };
let panOffsetTotal = { x:0, y:0 };
let coordSnapRestore = { active:false, prev:false };

let lasso = {
  points: [],
  selecting: false,
  selectedIdx: [],
  bbox: null,
  mode: "idle",       // idle | move
  moveStart: null
};

/* =====================
   Text drag (pointer tool)
   ===================== */
let textDrag = {
  active:false,
  layer:0,
  index:0,
  startClient:{x:0,y:0},
  startPos:{x:0,y:0}
};

/* =====================
   Utilities
   ===================== */
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }
function radToDeg(r){ return r * 180 / Math.PI; }
function normDegSigned(d){
  d = ((d + 180) % 360 + 360) % 360 - 180;
  return d;
}

function alphaFromTransp(t){
  // 1 = opaque, 10 = very transparent
  const a = 255 - (t-1) * (245/9);
  return Math.round(clamp(a, 8, 255));
}

function snapPoint(x,y){
  if (!snapToGrid) return {x,y};
  return { x: Math.round(x/GRID_STEP)*GRID_STEP, y: Math.round(y/GRID_STEP)*GRID_STEP };
}

function snapPointForced(x,y){
  return { x: Math.round(x/GRID_STEP)*GRID_STEP, y: Math.round(y/GRID_STEP)*GRID_STEP };
}

function quantizePoint(p){
  return { x: Math.round(p.x), y: Math.round(p.y) };
}

function quantizeScalar(v){
  return Math.round(v);
}

function pressureMultiplier(p, pointerType){
  const pr = Math.max(0, Math.min(1, (p ?? 1)));
  const isPen = (pointerType === "pen");
  if (!isPen && (pr === 0 || pr === 1)) return 1;
  return 0.45 + 1.10 * pr;
}

function escapeHTML(s){
  return String(s).replace(/[&<>"]/g, (c)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
}
function showCursorHint(text, ms=700){
  cursorHint.textContent = text;
  cursorHint.style.left = (lastPointerClient.x + 12) + "px";
  cursorHint.style.top  = (lastPointerClient.y + 12) + "px";
  cursorHint.classList.add("show");
  setTimeout(()=> cursorHint.classList.remove("show"), ms);
}
function showCursorHintWithColor(text, hex, ms=700){
  cursorHint.innerHTML = `<span>${escapeHTML(text)}</span><span class="hintChip" style="background:${escapeHTML(hex||"#111")}"></span>`;
  cursorHint.style.left = (lastPointerClient.x + 12) + "px";
  cursorHint.style.top  = (lastPointerClient.y + 12) + "px";
  cursorHint.classList.add("show");
  setTimeout(()=> cursorHint.classList.remove("show"), ms);
}

function getCSSNum(varName){
  const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  return parseFloat(v || "0");
}

/* HUD positioning: "top of screen, just left of toolbar head" */
let toastTimer = null;
function positionHudBox(boxEl, extraLeftGapPx){
  if (!dragHandle) return;
  const r = dragHandle.getBoundingClientRect();
  const GAP = (typeof extraLeftGapPx === "number") ? extraLeftGapPx : 10;

  boxEl.style.left = (r.left - GAP) + "px";
  boxEl.style.top  = (r.top + 2) + "px";
  boxEl.style.transform = "translate(-100%, 0)";
}

function showToast(msg, ms=1600){
  if (!toastBox) return;
  if (toastTimer) clearTimeout(toastTimer);
  toastBox.textContent = msg;
  positionHudBox(toastBox, 12);
  toastBox.classList.add("show");
  toastTimer = setTimeout(()=> toastBox.classList.remove("show"), ms);
}

let shortcutsVisible = false;

function positionShortcutBox(){
  if (!shortcutBox || !ui) return;
  const base = (exportRow && exportRow.offsetParent !== null) ? exportRow : dragHandle;
  if (!base) return;
  const r = base.getBoundingClientRect();
  shortcutBox.style.left = (r.left - 12) + "px";
  shortcutBox.style.top  = (r.top + 2) + "px";
  shortcutBox.style.transform = "translate(-100%, 0)";
}

function setShortcutBoxHTML(){
  if (!shortcutBox) return;
  shortcutBox.innerHTML = `
    <div class="title">Shortcuts</div>
    <div class="row"><span><code>Esc</code></span><span>Pointer</span></div>
    <div class="row"><span><code>P</code></span><span>Pen</span></div>
    <div class="row"><span><code>E</code></span><span>Eraser</span></div>
    <div class="row"><span><code>H</code></span><span>Highlighter</span></div>
    <div class="row"><span><code>O</code></span><span>Laser</span></div>
    <div class="row"><span><code>M</code></span><span>Pan</span></div>
    <div class="row"><span><code>S</code></span><span>Cycle shapes</span></div>
    <div class="row"><span><code>C</code></span><span>Cycle colors</span></div>
    <div class="row"><span><code>W</code></span><span>Cycle width</span></div>
    <div class="row"><span><code>Q</code></span><span>Cycle transp.</span></div>
    <div class="row"><span><code>A</code></span><span>Cycle smooth.</span></div>
    <div class="row"><span><code>Y</code></span><span>Next layer</span></div>
    <div class="row"><span><code>Z</code></span><span>Zoom in</span></div>
    <div class="row"><span><code>U</code></span><span>Zoom out</span></div>
    <div class="row"><span><code>R</code></span><span>Reset view</span></div>
    <div class="row"><span><code>Ctrl+1..9</code></span><span>Smooth 1..9</span></div>
    <div class="row"><span><code>1..9</code></span><span>Width presets</span></div>
    <div class="row"><span><code>Ctrl+Z</code></span><span>Undo</span></div>
    <div class="row"><span><code>Ctrl+D</code></span><span>Clear layer</span></div>
    <div class="row"><span><code>Del</code></span><span>Delete selection</span></div>
  `;
}

function showShortcutsBox(){
  if (!shortcutBox) return;
  setShortcutBoxHTML();
  positionShortcutBox();
  shortcutBox.classList.add("show");
  shortcutsVisible = true;
}

function hideShortcutsBox(){
  if (!shortcutBox) return;
  shortcutBox.classList.remove("show");
  shortcutsVisible = false;
}

function toggleShortcutsBox(){
  if (shortcutsVisible) hideShortcutsBox();
  else showShortcutsBox();
}

function hideMeasureBox(){
  measureBox.classList.remove("show");
}

function showMeasureBox(parts){
  if (!dragHandle) return;
  measureBox.textContent = parts.join("   ");
  positionHudBox(measureBox, 14);
  measureBox.classList.add("show");
}

function pointInPoly(pt, poly){
  let inside=false;
  for (let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i].x, yi=poly[i].y;
    const xj=poly[j].x, yj=poly[j].y;
    const denom=(yj-yi)||1e-9;
    const intersect=((yi>pt.y)!==(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/denom + xi);
    if (intersect) inside=!inside;
  }
  return inside;
}

/* =====================
   Selection / bbox helpers
   ===================== */
function pathBBox(a){
  const pts=a.points || [];
  if(!pts.length) return {x:0,y:0,w:0,h:0};
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of pts){
    minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
    maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
  }
  const pad = Math.max(6, (a.style?.baseWeight || 2) * 2);
  return { x:minX-pad, y:minY-pad, w:(maxX-minX)+2*pad, h:(maxY-minY)+2*pad };
}
function ellipseBBox(a){
  const cx=(a.a.x+a.b.x)/2, cy=(a.a.y+a.b.y)/2;
  const major = dist(a.a.x,a.a.y,a.b.x,a.b.y);
  const e = (typeof a.e === "number") ? a.e : ELLIPSE_E;
  const minor = major * Math.sqrt(1 - e*e);
  const ang = Math.atan2(a.b.y-a.a.y, a.b.x-a.a.x);
  const A = major/2, B = minor/2;
  const c=Math.cos(ang), s=Math.sin(ang);
  const hw = Math.sqrt((A*c)**2 + (B*s)**2);
  const hh = Math.sqrt((A*s)**2 + (B*c)**2);
  return { x:cx-hw, y:cy-hh, w:2*hw, h:2*hh };
}
function actionBBox(a){
  if (a.type==="text"){
    const w = a.w || Math.max(40, Math.min(520, (a.size||20) * 0.62 * (a.raw?.length||1)));
    const h = a.h || Math.max(16, Math.min(240, (a.size||20) * 1.4));
    return { x:a.x, y:a.y, w, h };
  }
  if (a.type==="path") return pathBBox(a);
  if (a.type==="ellipse") return ellipseBBox(a);
  if (a.type==="line"||a.type==="arrow"||a.type==="rect"||a.type==="shadowRect"||a.type==="titleBox"||a.type==="rightTri"||(a.type==="coord1" || a.type==="coord2" || a.type==="coord3")){
    const minX=Math.min(a.a.x,a.b.x), minY=Math.min(a.a.y,a.b.y);
    const maxX=Math.max(a.a.x,a.b.x), maxY=Math.max(a.a.y,a.b.y);
    return { x:minX, y:minY, w:maxX-minX, h:maxY-minY };
  }
  if (a.type==="circle"){
    return { x:a.c.x-a.r, y:a.c.y-a.r, w:2*a.r, h:2*a.r };
  }
  if (a.type==="fill"){
    return { x:a.x-8, y:a.y-8, w:16, h:16 };
  }
  return { x:0,y:0,w:0,h:0 };
}

function computeWorldBounds(){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  let any=false;
  let hasFill=false;

  for (let li=0; li<3; li++){
    if (!layers[li].visible) continue;
    const actions = layers[li].actions || [];
    for (const a of actions){
      if (!a) continue;

      if (a.type === "fill"){
        hasFill = true;
        continue;
      }

      const bb = actionBBox(a);
      if (!bb) continue;
      if (bb.w === 0 && bb.h === 0) continue;
      minX = Math.min(minX, bb.x);
      minY = Math.min(minY, bb.y);
      maxX = Math.max(maxX, bb.x + bb.w);
      maxY = Math.max(maxY, bb.y + bb.h);
      any = true;
    }
  }

  // If any fill exists we must assume it could extend to the canvas edges,
  // otherwise exports may get clipped.
  if (hasFill){
    minX = Math.min(minX, 0);
    minY = Math.min(minY, 0);
    maxX = Math.max(maxX, width);
    maxY = Math.max(maxY, height);
    any = true;
  }

  if (!any) return null;
  return { x:minX, y:minY, w: maxX-minX, h: maxY-minY };
}

async function computeExportBounds(){
  // Ensure text overlay exists + MathJax rendered so SVG sizes are measurable
  rebuildTextOverlay();
  await typesetTextOverlay();

  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  let any=false;
  let hasFill=false;

  for (let li=0; li<3; li++){
    if (!layers[li].visible) continue;
    const actions = layers[li].actions || [];
    for (let i=0;i<actions.length;i++){
      const a = actions[i];
      if (!a) continue;

      if (a.type === "fill"){
        hasFill = true;
        continue;
      }

      // Special-case text: prefer actual DOM size if available
      if (a.type === "text"){
        const node = textOverlay.querySelector(`.text-box[data-layer="${li}"][data-index="${i}"]`);
        const w = node ? node.offsetWidth  : (a.w || Math.max(40, Math.min(520, (a.size||20) * 0.62 * ((a.raw||"").length||1))));
        const h = node ? node.offsetHeight : (a.h || Math.max(16, Math.min(240, (a.size||20) * 1.4)));
        const bb = { x:a.x, y:a.y, w, h };
        minX = Math.min(minX, bb.x);
        minY = Math.min(minY, bb.y);
        maxX = Math.max(maxX, bb.x + bb.w);
        maxY = Math.max(maxY, bb.y + bb.h);
        any = true;
        continue;
      }

      const bb = actionBBox(a);
      if (!bb) continue;
      if (bb.w === 0 && bb.h === 0) continue;
      minX = Math.min(minX, bb.x);
      minY = Math.min(minY, bb.y);
      maxX = Math.max(maxX, bb.x + bb.w);
      maxY = Math.max(maxY, bb.y + bb.h);
      any = true;
    }
  }

  if (hasFill){
    minX = Math.min(minX, 0);
    minY = Math.min(minY, 0);
    maxX = Math.max(maxX, width);
    maxY = Math.max(maxY, height);
    any = true;
  }

  if (!any) return null;
  return { x:minX, y:minY, w: maxX-minX, h: maxY-minY };
}

function translateAction(a,dx,dy){
  if (a.type==="text"){ a.x+=dx; a.y+=dy; }
  else if (a.type==="path"){ for(const p of a.points){ p.x+=dx; p.y+=dy; } }
  else if (a.type==="ellipse"){ a.a.x+=dx; a.a.y+=dy; a.b.x+=dx; a.b.y+=dy; }
  else if (a.type==="line"||a.type==="arrow"||a.type==="rect"||a.type==="shadowRect"||a.type==="titleBox"||a.type==="rightTri"||(a.type==="coord1" || a.type==="coord2" || a.type==="coord3")){ a.a.x+=dx; a.a.y+=dy; a.b.x+=dx; a.b.y+=dy; }
  else if (a.type==="circle"){ a.c.x+=dx; a.c.y+=dy; }
  else if (a.type==="fill"){ a.x+=dx; a.y+=dy; }
}
function clearSelection(){
  lasso.points=[];
  lasso.selecting=false;
  lasso.selectedIdx=[];
  lasso.bbox=null;
  lasso.mode="idle";
  lasso.moveStart=null;
}
function recomputeSelectionBBox(){
  const L=layers[activeLayer];
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const idx of lasso.selectedIdx){
    const bb=actionBBox(L.actions[idx]);
    minX=Math.min(minX,bb.x); minY=Math.min(minY,bb.y);
    maxX=Math.max(maxX,bb.x+bb.w); maxY=Math.max(maxY,bb.y+bb.h);
  }
  lasso.bbox={x:minX,y:minY,w:maxX-minX,h:maxY-minY};
}
function lassoSelect(){
  const poly = lasso.points.slice();
  lasso.points=[];
  if(poly.length<3){ clearSelection(); return; }

  const L=layers[activeLayer];
  const selected=[];
  for(let i=0;i<L.actions.length;i++){
    const a=L.actions[i];
    const bb=actionBBox(a);
    const corners=[
      {x:bb.x,y:bb.y},{x:bb.x+bb.w,y:bb.y},
      {x:bb.x+bb.w,y:bb.y+bb.h},{x:bb.x,y:bb.y+bb.h}
    ];
    const center={x:bb.x+bb.w/2,y:bb.y+bb.h/2};

    let hit = corners.some(p=>pointInPoly(p,poly)) || pointInPoly(center,poly);
    if(!hit && a.type==="path"){
      for(const p of (a.points||[])){
        if(pointInPoly({x:p.x,y:p.y}, poly)){ hit=true; break; }
      }
    }
    if(hit) selected.push(i);
  }

  lasso.selectedIdx=selected;
  if(!selected.length){ lasso.bbox=null; return; }
  recomputeSelectionBBox();
}
function pointInBBox(x,y,bb){
  if(!bb) return false;
  return (x>=bb.x && x<=bb.x+bb.w && y>=bb.y && y<=bb.y+bb.h);
}
function deleteSelection(){
  if(!lasso.selectedIdx.length) return;
  pushUndo(activeLayer);
  const L=layers[activeLayer];
  const idxs = lasso.selectedIdx.slice().sort((a,b)=>b-a);
  for(const idx of idxs) L.actions.splice(idx,1);
  L.actions = L.actions.filter(a => a.type !== "fill");

  clearSelection();
  rebuildLayerBuffer(activeLayer);
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   Undo
   ===================== */
function pushUndo(layerIndex){
  const L = layers[layerIndex];
  undoStack[layerIndex].push(JSON.stringify({ actions: L.actions, visible: L.visible }));
  if (undoStack[layerIndex].length > UNDO_LIMIT) undoStack[layerIndex].shift();
}
function undoActiveLayer(){
  const st = undoStack[activeLayer];
  if (!st.length) return;
  const snap = JSON.parse(st.pop());
  layers[activeLayer].actions = snap.actions || [];
  layers[activeLayer].visible = (typeof snap.visible==="boolean") ? snap.visible : true;
  rebuildLayerBuffer(activeLayer);
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   p5 setup/draw
   ===================== */
function setup(){
  const c = createCanvas(windowWidth, windowHeight);
  c.parent("canvas-wrap");
  pixelDensity(1);

  layers = [];
  for (let i=0;i<3;i++){
    const pg = createGraphics(windowWidth, windowHeight);
    pg.pixelDensity(1);
    pg.clear();
    layers.push({ pg, actions: [], visible: true });
  }

  slideKey = getSlideKeyFromURL();
  lastSlideKey = slideKey;

  initUI();
  applyZoom();


  loadFromStorage(slideKey);
  rebuildAllBuffers();
  rebuildTextOverlay();

  // poll for slide changes
  setInterval(()=>{
    const k = getSlideKeyFromURL();
    if (k && k !== lastSlideKey){
      saveToStorage(lastSlideKey);
      lastSlideKey = k;
      slideKey = k;

      for (let i=0;i<3;i++){ layers[i].actions=[]; layers[i].visible=true; layers[i].pg.clear(); }
      loadFromStorage(slideKey);
      rebuildAllBuffers();
      rebuildTextOverlay();
    }
  }, 350);

  document.addEventListener("visibilitychange", ()=>{
    if (document.hidden) saveToStorage(slideKey);
  });
  window.addEventListener("beforeunload", ()=> saveToStorage(slideKey));

  const canvasEl = document.querySelector("canvas");
  canvasEl.style.touchAction="none";
  canvasEl.addEventListener("pointerdown", onPointerDown, {passive:false});
  canvasEl.addEventListener("pointermove", onPointerMove, {passive:false});
  canvasEl.addEventListener("pointerup", onPointerUp, {passive:false});
  canvasEl.addEventListener("pointercancel", onPointerUp, {passive:false});

  document.addEventListener("pointerdown",(ev)=>{
    if (textEditor.style.display==="none") return;
    if (textEditor.contains(ev.target)) return;
    commitTextEdit();
  }, {capture:true});


  textInput.addEventListener("keydown",(ev)=>{
    if ((ev.ctrlKey||ev.metaKey) && ev.key==="Enter"){
      ev.preventDefault();
      commitTextEdit();
    } else if (ev.key==="Escape"){
      ev.preventDefault();
      cancelTextEdit();
      setTool("pointer");
    }
  });
  textOkBtn.addEventListener("click", (ev)=>{
    ev.preventDefault();
    commitTextEdit();
  });

  document.addEventListener("keydown", onKeyDown);
  document.addEventListener("keyup", (ev)=>{ if (ev.key==="Shift") isShiftDown=false; });

  setTool("pen");
}

function draw(){
  clear();

  drawBackgroundOverlay(this, bgMode);
  renderLayers(this);

  if (current && current.type !== "laser" && tool!=="lasso") drawCurrentPreview(current);
  drawLassoOverlay();

  updateLaserTrail();
  drawLaserTrail();
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  for (let i=0;i<3;i++){
    const old=layers[i].pg;
    const ng=createGraphics(windowWidth, windowHeight);
    ng.pixelDensity(1);
    ng.clear();
    ng.image(old,0,0);
    layers[i].pg = ng;
  }
  rebuildAllBuffers();
  rebuildTextOverlay();
}

/* =====================
   Background overlay
   ===================== */
function drawBackgroundOverlay(target, mode){
  if (mode==="transparent") return;

  const gridA = getCSSNum("--grid-a");
  const dotsA = getCSSNum("--dots-a");
  const dotsR = getCSSNum("--dots-r");

  if (mode==="grid"){
    target.push();
    target.stroke(0, gridA);
    target.strokeWeight(1);
    for (let x=0;x<width;x+=GRID_STEP) target.line(x,0,x,height);
    for (let y=0;y<height;y+=GRID_STEP) target.line(0,y,width,y);
    target.pop();
    return;
  }

  target.push();
  target.noStroke();
  target.fill(0, dotsA);
  for (let x=0;x<width;x+=GRID_STEP){
    for (let y=0;y<height;y+=GRID_STEP){
      target.circle(x,y,dotsR);
    }
  }
  target.pop();
}

/* =====================
   Actions: draw helpers
   ===================== */
function makeStyleForCurrent(pressure, pointerType){
  const mult = pressureMultiplier(pressure, pointerType);
  const w = strokeWidth * mult;
  const alpha = alphaFromTransp(transp);
  if (tool==="eraser") return { eraser:true, baseWeight:strokeWidth, weight:w, color:null, alpha:255, smoothing };
  return { eraser:false, baseWeight:strokeWidth, weight:w, color:currentColor, alpha, smoothing };
}

function drawArrowHead(target, x1,y1,x2,y2, style){
  const ang = Math.atan2(y2-y1, x2-x1);
  const w = Math.max(1, style.weight || 1);
  const headLen = Math.max(10, 3.2*w);
  const headAng = (28*Math.PI)/180;
  const x3 = x2 - headLen*Math.cos(ang - headAng);
  const y3 = y2 - headLen*Math.sin(ang - headAng);
  const x4 = x2 - headLen*Math.cos(ang + headAng);
  const y4 = y2 - headLen*Math.sin(ang + headAng);
  target.line(x2,y2,x3,y3);
  target.line(x2,y2,x4,y4);
}

function drawShapeAction(a, target){
  const st=a.style;

  if (st.eraser){
    target.erase(); target.stroke(0);
    target.strokeWeight(st.weight); target.strokeCap(ROUND); target.strokeJoin(ROUND); target.noFill();
  } else {
    const col=color(st.color); col.setAlpha(st.alpha??255);
    target.stroke(col); target.strokeWeight(st.weight); target.strokeCap(ROUND); target.strokeJoin(ROUND); target.noFill();
  }

  if (a.type==="line") target.line(a.a.x,a.a.y,a.b.x,a.b.y);

  else if (a.type==="arrow"){
    target.line(a.a.x,a.a.y,a.b.x,a.b.y);
    drawArrowHead(target,a.a.x,a.a.y,a.b.x,a.b.y,st);
  }

  else if (a.type==="circle") target.circle(a.c.x,a.c.y,2*a.r);

  else if (a.type==="rect" || a.type==="shadowRect"){
    const x=Math.min(a.a.x,a.b.x), y=Math.min(a.a.y,a.b.y);
    const w=Math.abs(a.b.x-a.a.x), h=Math.abs(a.b.y-a.a.y);

    if (a.type==="shadowRect" && !st.eraser){
      const ctx = target.drawingContext;
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 18;
      ctx.shadowOffsetX = 4;
      ctx.shadowOffsetY = 4;

      // Fill with user color, but with translucency level 10 (very transparent)
      const fillCol = color(st.color);
      fillCol.setAlpha(alphaFromTransp(10));
      target.fill(fillCol);

      const rr = 10;
      target.rect(x,y,w,h, rr);

      target.noFill();
      ctx.restore();
    } else {
      target.rect(x,y,w,h);
    }
  }



  else if (a.type=="titleBox"){
    const x=Math.min(a.a.x,a.b.x), y=Math.min(a.a.y,a.b.y);
    const w=Math.abs(a.b.x-a.a.x), h=Math.abs(a.b.y-a.a.y);
    if (w<2 || h<2) return;

    // Simple ribbon-style title box (outline only)
    const rr = Math.min(18, h*0.45);
    const tail = Math.min(w*0.18, h*0.9);

    // Main rounded box
    target.push();
    target.noFill();
    target.rect(x+tail, y, w-2*tail, h, rr);

    // Left ribbon tail
    target.beginShape();
    target.vertex(x+tail, y);
    target.vertex(x, y + h*0.20);
    target.vertex(x, y + h*0.80);
    target.vertex(x+tail, y + h);
    target.endShape(CLOSE);

    // Right ribbon tail
    target.beginShape();
    target.vertex(x+w-tail, y);
    target.vertex(x+w, y + h*0.20);
    target.vertex(x+w, y + h*0.80);
    target.vertex(x+w-tail, y + h);
    target.endShape(CLOSE);

    // Small inner fold lines
    target.line(x+tail, y+h, x+tail*0.55, y+h*0.60);
    target.line(x+w-tail, y+h, x+w-tail*0.55, y+h*0.60);
    target.pop();
  }
  else if (a.type==="rightTri"){
    // First click fixes a point on the horizontal base line (A). Drag point (C) sets size.
    // Right angle is at B, which lies on the base line at the dragged x-position.
    const A = {x:a.a.x, y:a.a.y};
    const C = {x:a.b.x, y:a.b.y};
    const B = {x:C.x, y:A.y};
    target.line(A.x,A.y,B.x,B.y);
    target.line(B.x,B.y,C.x,C.y);
    target.line(C.x,C.y,A.x,A.y);
  }

else if (a.type==="coord1" || a.type==="coord2" || a.type==="coord3"){
    const ox = a.a.x, oy = a.a.y;
    const dxRaw = a.b.x - a.a.x;
    const dyRaw = a.b.y - a.a.y;

    const dx = (dxRaw===0) ? GRID_STEP*4 : dxRaw;
    const dy = (dyRaw===0) ? GRID_STEP*4 : dyRaw;

    const xLen = Math.abs(dx), yLen = Math.abs(dy);
    const xDir = dx >= 0 ? 1 : -1;
    const yDir = dy >= 0 ? 1 : -1;

    const xPosEnd = ox + xDir * xLen;
    const yPosEnd = oy + yDir * yLen;
    const xNegEnd = ox - xDir * xLen;
    const yNegEnd = oy - yDir * yLen;

    // Determine grid bounds
    let x1 = Math.min(ox, xPosEnd), x2 = Math.max(ox, xPosEnd);
    let y1 = Math.min(oy, yPosEnd), y2 = Math.max(oy, yPosEnd);

    if (a.type==="coord2"){
      y1 = Math.min(y1, yNegEnd);
      y2 = Math.max(y2, yNegEnd);
    }
    if (a.type==="coord3"){
      x1 = Math.min(x1, xNegEnd);
      x2 = Math.max(x2, xNegEnd);
      y1 = Math.min(y1, yNegEnd);
      y2 = Math.max(y2, yNegEnd);
    }

    // Grid (same spacing as canvas grid)
    target.push();
    target.stroke(0, getCSSNum("--grid-a"));
    target.strokeWeight(1);
    for (let x = Math.ceil(x1/GRID_STEP)*GRID_STEP; x <= x2; x += GRID_STEP) target.line(x, y1, x, y2);
    for (let y = Math.ceil(y1/GRID_STEP)*GRID_STEP; y <= y2; y += GRID_STEP) target.line(x1, y, x2, y);
    target.pop();

    // Axes (arrows)
    // X axis
    if (a.type==="coord3"){
      target.line(xNegEnd, oy, xPosEnd, oy);
      drawArrowHead(target, ox, oy, xPosEnd, oy, st);
      drawArrowHead(target, ox, oy, xNegEnd, oy, st);
    } else {
      target.line(ox, oy, xPosEnd, oy);
      drawArrowHead(target, ox, oy, xPosEnd, oy, st);
    }

    // Y axis
    if (a.type==="coord2" || a.type==="coord3"){
      target.line(ox, yNegEnd, ox, yPosEnd);
      drawArrowHead(target, ox, oy, ox, yPosEnd, st);
      drawArrowHead(target, ox, oy, ox, yNegEnd, st);
    } else {
      target.line(ox, oy, ox, yPosEnd);
      drawArrowHead(target, ox, oy, ox, yPosEnd, st);
    }
  }


  else if (a.type==="ellipse"){
    const cx=(a.a.x+a.b.x)/2, cy=(a.a.y+a.b.y)/2;
    const major = dist(a.a.x,a.a.y,a.b.x,a.b.y);
    const e = (typeof a.e === "number") ? a.e : ELLIPSE_E;
    const minor = major * Math.sqrt(1 - e*e);
    const ang = Math.atan2(a.b.y-a.a.y, a.b.x-a.a.x);
    target.push();
    target.translate(cx,cy);
    target.rotate(ang);
    target.ellipse(0,0, major, minor);
    target.pop();
  }

  if (st.eraser) target.noErase();
}

function renderAction(a, target){
  if (!a) return;
  if (a.type === "path"){
    const pts = a.points || [];
    for (let k=1;k<pts.length;k++){
      const p0=pts[k-1], p1=pts[k];
      const avgP=((p0.p??1)+(p1.p??1))/2;
      const mult=pressureMultiplier(avgP, "pen");
      const w=(a.style.baseWeight||2)*mult;

      if (a.style.eraser){
        target.erase();
        target.stroke(0); target.strokeWeight(w);
        target.strokeCap(ROUND); target.strokeJoin(ROUND);
        target.line(p0.x,p0.y,p1.x,p1.y);
        target.noErase();
      } else {
        const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
        target.stroke(col); target.strokeWeight(w);
        target.strokeCap(ROUND); target.strokeJoin(ROUND);
        target.line(p0.x,p0.y,p1.x,p1.y);
      }
    }
    return;
  }
  if (a.type === "fill"){
    // NOTE: flood-fill is raster-based; in pan/zoom mode we don't re-run it on every frame.
    // Keep stored actions for compatibility, but do not attempt to redraw fills here.
    return;
  }
  if (a.type === "text") return;
  drawShapeAction(a, target);
}

function renderLayers(target){
  for (let i=0;i<3;i++){
    if (!layers[i].visible) continue;
    if (layers[i].pg) target.image(layers[i].pg, 0, 0);
  }
}

function updateMeasureForCurrentShape(){
  if (!current) { hideMeasureBox(); return; }
  if (!(current.type==="line" || current.type==="arrow" || current.type==="circle" || current.type==="rect" || current.type==="shadowRect" || current.type==="titleBox" || current.type==="rightTri")) { hideMeasureBox(); return; }

  if ((current.type==="line" || current.type==="arrow") && current.a && current.b){
    const dx = current.b.x - current.a.x;
    const dy = current.b.y - current.a.y;
    const len = Math.hypot(dx,dy);
    if (len < 2){ hideMeasureBox(); return; }

    const lenPx = quantizeScalar(len);
    const deg = Math.round(normDegSigned(radToDeg(Math.atan2(dy, dx))));
    showMeasureBox([`L: ${lenPx} px`, `Œ±: ${deg}¬∞`]);
    return;
  }

  if (current.type==="circle" && current.r!=null){
    showMeasureBox([`r: ${quantizeScalar(Math.max(0,current.r))} px`]);
    return;
  }

  if ((current.type==="rect" || current.type==="shadowRect" || current.type==="titleBox") && current.a && current.b){
    const w = Math.abs(current.b.x-current.a.x);
    const h = Math.abs(current.b.y-current.a.y);
    if (w<1 && h<1){ hideMeasureBox(); return; }
    showMeasureBox([`w: ${quantizeScalar(w)} px`, `h: ${quantizeScalar(h)} px`]);
    return;
  }

  if (current.type==="rightTri" && current.a && current.b){
    const w = Math.abs(current.b.x-current.a.x);
    const h = Math.abs(current.b.y-current.a.y);
    if (w<1 && h<1){ hideMeasureBox(); return; }
    const ang = (w < 1) ? 90 : Math.round(radToDeg(Math.atan2(h, w)));
    showMeasureBox([`w: ${quantizeScalar(w)} px`, `h: ${quantizeScalar(h)} px`, `Œ±: ${ang}¬∞`]);
    return;
  }
}

function drawCurrentPreview(a){
  updateMeasureForCurrentShape();

  if (a.type==="path"){
    push();
    const pts=a.points;
    for (let k=1;k<pts.length;k++){
      const p0=pts[k-1], p1=pts[k];
      const avgP=((p0.p??1)+(p1.p??1))/2;
      const mult=pressureMultiplier(avgP, a.pointerType||"pen");
      const w=(a.style.baseWeight||2)*mult;

      if (a.style.eraser){
        erase();
        stroke(0); strokeWeight(w); strokeCap(ROUND); strokeJoin(ROUND);
        line(p0.x,p0.y,p1.x,p1.y);
        noErase();
      } else {
        const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
        stroke(col); strokeWeight(w); strokeCap(ROUND); strokeJoin(ROUND);
        line(p0.x,p0.y,p1.x,p1.y);
      }
    }
    pop();
    return;
  }

  if (["line","arrow","circle","rect","shadowRect","rightTri","titleBox","coord1","coord2","coord3","ellipse","ellipse99"].includes(a.type)){
    push();
    drawShapeAction(a, this);
    pop();
  }
}

/* =====================
   Fill tool
   ===================== */
function floodFillOnLayer(layerIndex, x, y, fillHex, fillAlpha){
  const L = layers[layerIndex];
  const pg = L.pg;

  const ix = Math.floor(clamp(x, 0, width-1));
  const iy = Math.floor(clamp(y, 0, height-1));

  pg.loadPixels();
  const pix = pg.pixels;
  const W = width, H = height;

  const idx0 = 4*(iy*W + ix);
  const a0=pix[idx0+3];
  if (a0 > 12) return false;

  const c = color(fillHex);
  const fr = Math.round(red(c));
  const fg = Math.round(green(c));
  const fb = Math.round(blue(c));
  const fa = fillAlpha;

  const stack = [[ix,iy]];
  const visited = new Uint8Array(W*H);

  let filled=0;
  const MAX = 650000;

  while(stack.length){
    const [cx,cy] = stack.pop();
    const p = cy*W + cx;
    if (visited[p]) continue;
    visited[p]=1;

    const off = 4*p;
    const a = pix[off+3];
    if (a > 12) continue;

    pix[off]=fr; pix[off+1]=fg; pix[off+2]=fb; pix[off+3]=fa;
    filled++;
    if (filled > MAX) break;

    if (cx>0) stack.push([cx-1,cy]);
    if (cx<W-1) stack.push([cx+1,cy]);
    if (cy>0) stack.push([cx,cy-1]);
    if (cy<H-1) stack.push([cx,cy+1]);
  }

  pg.updatePixels();
  return filled>0;
}

/* =====================
   Rebuild layer buffers
   ===================== */
function rebuildLayerBuffer(i){
  const L=layers[i];
  L.pg.clear();

  for (const a of L.actions){
    if (a.type==="text" || a.type==="fill") continue;

    if (a.type==="path"){
      const pts=a.points;
      for (let k=1;k<pts.length;k++){
        const p0=pts[k-1], p1=pts[k];
        const avgP=((p0.p??1)+(p1.p??1))/2;
        const mult=pressureMultiplier(avgP, "pen");
        const w=(a.style.baseWeight||2)*mult;

        if (a.style.eraser){
          L.pg.erase();
          L.pg.stroke(0); L.pg.strokeWeight(w);
          L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
          L.pg.line(p0.x,p0.y,p1.x,p1.y);
          L.pg.noErase();
        } else {
          const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
          L.pg.stroke(col); L.pg.strokeWeight(w);
          L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
          L.pg.line(p0.x,p0.y,p1.x,p1.y);
        }
      }
      continue;
    }

    L.pg.push();
    drawShapeAction(a, L.pg);
    L.pg.pop();
  }

  for (const a of L.actions){
    if (a.type!=="fill") continue;
    floodFillOnLayer(i, a.x, a.y, a.color, a.alpha);
  }
}
function rebuildAllBuffers(){ for (let i=0;i<3;i++) rebuildLayerBuffer(i); }

/* =====================
   Laser
   ===================== */
function updateLaserTrail(){
  const now=millis();
  laserTrail = laserTrail.filter(p=> now-p.t < LASER_FADE_MS);
}
function drawLaserTrail(){
  if(!laserTrail.length) return;

  const w = Math.max(1, strokeWidth);
  const c = color(currentColor);

  push(); noFill();
  for(let i=1;i<laserTrail.length;i++){
    const p=laserTrail[i-1], q=laserTrail[i];
    const age=millis()-q.t;
    const a=map(age,0,LASER_FADE_MS,200,0,true);
    stroke(red(c),green(c),blue(c),a);
    strokeWeight(w); strokeCap(ROUND);
    line(p.x,p.y,q.x,q.y);
  }
  const last=laserTrail[laserTrail.length-1];
  stroke(red(c),green(c),blue(c),210);
  strokeWeight(Math.max(8, w*2.2));
  point(last.x,last.y);
  pop();
}

/* =====================
   Lasso overlay
   ===================== */
function drawLassoOverlay(){
  if (tool==="lasso" && lasso.selecting && lasso.points.length){
    push(); noFill();
    stroke(0, 90);
    strokeWeight(2);
    beginShape(); for(const p of lasso.points) vertex(p.x,p.y); endShape();
    pop();
  }

  if (lasso.selectedIdx.length && lasso.bbox){
    const bb = lasso.bbox;
    push();
    noFill();
    stroke(0, 140);
    strokeWeight(2);
    drawingContext.setLineDash([6,6]);
    rect(bb.x, bb.y, bb.w, bb.h);
    drawingContext.setLineDash([]);
    pop();
  }
}

/* =====================
   Line/arrow alignment
   ===================== */
function maybeAlignLineLike(a){
  if (!a || !(a.type==="line" || a.type==="arrow")) return;
  const dx = a.b.x - a.a.x;
  const dy = a.b.y - a.a.y;
  if (Math.abs(dx) >= Math.abs(dy)) a.b.y = a.a.y;
  else a.b.x = a.a.x;
}
function clearHoldAlignTimer(){
  if (holdAlignTimer){ clearTimeout(holdAlignTimer); holdAlignTimer=null; }
}
function armHoldAlignTimer(){
  clearHoldAlignTimer();
  holdAlignTimer = setTimeout(()=>{
    if (!current) return;

    if (current.type==="line" || current.type==="arrow"){
      maybeAlignLineLike(current);
      return;
    }

    if (current.type==="path" && tool==="pen"){
      const lineObj = maybeConvertPathToAxisLine(current);
      if (lineObj){
        current = lineObj;
        maybeAlignLineLike(current);
      }
    }
  }, HOLD_ALIGN_MS);
}
function isStill(now, x, y){
  const moved = dist2(x,y,lastMovePos.x,lastMovePos.y) > STILL_EPS_PX*STILL_EPS_PX;
  if (moved){
    lastMovePos = {x,y};
    lastSignificantMoveAt = now;
    clearHoldAlignTimer();
    return false;
  }
  return (now - lastSignificantMoveAt) > STILL_TIME_MS;
}
function pointLineDist(px,py, ax,ay, bx,by){
  const vx=bx-ax, vy=by-ay;
  const wx=px-ax, wy=py-ay;
  const c1 = vx*wx + vy*wy;
  const c2 = vx*vx + vy*vy || 1e-9;
  const t = c1 / c2;
  const projx = ax + t*vx;
  const projy = ay + t*vy;
  return Math.hypot(px-projx, py-projy);
}
function maybeConvertPathToAxisLine(pathAction){
  const pts = pathAction.points || [];
  if (pts.length < 3) return null;
  const a0 = pts[0];
  const a1 = pts[pts.length-1];
  const len = Math.hypot(a1.x-a0.x, a1.y-a0.y);
  if (len < FREE_LINE_MIN_LENGTH) return null;

  let maxD = 0;
  for (const p of pts){
    maxD = Math.max(maxD, pointLineDist(p.x,p.y,a0.x,a0.y,a1.x,a1.y));
    if (maxD > FREE_LINE_MAX_DEVIATION) return null;
  }

  const st = {
    eraser:false,
    weight: pathAction.style.baseWeight || strokeWidth,
    color: pathAction.style.color || currentColor,
    alpha: pathAction.style.alpha ?? alphaFromTransp(transp)
  };

  return { type:"line", style: st, a:{x:a0.x,y:a0.y}, b:{x:a1.x,y:a1.y}, layer: pathAction.layer };
}

/* =====================
   Text overlay + MathJax v2 SVG
   ===================== */
function typesetTextOverlay(){
  if (!window.MathJax || !MathJax.Hub) return Promise.resolve();
  return new Promise((resolve)=>{
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, textOverlay]);
    MathJax.Hub.Queue(()=> resolve());
  });
}
function applyTextStyleToNode(node, style){
  node.style.fontFamily = '"Libertinus Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  if (style === "bold"){
    node.style.fontWeight = "700";
    node.style.fontStyle = "normal";
  } else if (style === "italic"){
    node.style.fontWeight = "400";
    node.style.fontStyle = "italic";
  } else {
    node.style.fontWeight = "400";
    node.style.fontStyle = "normal";
  }
}
function rebuildTextOverlay(){
  textOverlay.innerHTML = "";

  for (let li=0; li<3; li++){
    if (!layers[li].visible) continue;
    const actions = layers[li].actions;
    for (let i=0;i<actions.length;i++){
      const a = actions[i];
      if (a.type!=="text") continue;

      const div = document.createElement("div");
      div.className = "text-box";
      div.style.left = a.x + "px";
      div.style.top  = a.y + "px";
      div.style.fontSize = (a.size || 20) + "px";

      const allowEdit = (tool==="text");
      const allowDrag = (tool==="pointer");
      div.style.pointerEvents = (allowEdit || allowDrag) ? "auto" : "none";
      div.classList.toggle("draggable", allowDrag);

      applyTextStyleToNode(div, a.style || "regular");
      div.textContent = a.raw;

      div.dataset.layer = String(li);
      div.dataset.index = String(i);

      div.addEventListener("pointerdown",(ev)=>{
        if (tool==="text"){
          ev.stopPropagation();
          openTextEditor(a.x, a.y, a.raw, a.size, a.style, i, li);
          return;
        }
        if (tool==="pointer"){
          ev.stopPropagation();
          textDrag.active = true;
          textDrag.layer = li;
          textDrag.index = i;
          textDrag.startClient = {x: ev.clientX, y: ev.clientY};
          textDrag.startPos = {x: a.x, y: a.y};
          div.classList.add("dragging");
          div.setPointerCapture(ev.pointerId);
        }
      });

      div.addEventListener("pointermove",(ev)=>{
        if (!textDrag.active) return;
        if (tool!=="pointer") return;
        if (parseInt(div.dataset.layer,10)!==textDrag.layer) return;
        if (parseInt(div.dataset.index,10)!==textDrag.index) return;

        ev.preventDefault();
        const dx = ev.clientX - textDrag.startClient.x;
        const dy = ev.clientY - textDrag.startClient.y;

        const act = layers[textDrag.layer].actions[textDrag.index];
        if (!act || act.type!=="text") return;

        act.x = textDrag.startPos.x + dx;
        act.y = textDrag.startPos.y + dy;

        div.style.left = act.x + "px";
        div.style.top  = act.y + "px";
      });

      div.addEventListener("pointerup",()=>{
        if (!textDrag.active) return;
        if (parseInt(div.dataset.layer,10)!==textDrag.layer) return;
        if (parseInt(div.dataset.index,10)!==textDrag.index) return;

        textDrag.active=false;
        div.classList.remove("dragging");
        rebuildTextOverlay();
        saveToStorage(slideKey);
      });

      textOverlay.appendChild(div);
    }
  }

  setTimeout(async ()=>{
    await typesetTextOverlay();
    for (let li=0; li<3; li++){
      const nodes = textOverlay.querySelectorAll(`.text-box[data-layer="${li}"]`);
      nodes.forEach(node=>{
        const idx = parseInt(node.dataset.index,10);
        const act = layers[li].actions[idx];
        if (act && act.type==="text"){
          act.w = node.offsetWidth;
          act.h = node.offsetHeight;
        }
      });
    }
  }, 0);
}

function openTextEditor(x,y,raw,size,style,actionIndex, layerIndex){
  const li = (typeof layerIndex === "number") ? layerIndex : activeLayer;

  const s = size || defaultTextSize || 20;
  defaultTextSize = s;
  textSizeEditor.value = String(s);

  const st = style || defaultTextStyle || "regular";
  defaultTextStyle = st;
  textStyleEditor.value = st;

  textDraft={ layer:li, actionIndex, x,y, raw, size:s, style:st };
  textEditor.style.display="block";
  textInput.value = raw || "";

  const pad=10, ew=420, eh=220;
  let left = clamp(x+pad, 8, window.innerWidth-ew-8);
  let top  = clamp(y+pad, 8, window.innerHeight-eh-8);
  textEditor.style.left = `${left}px`;
  textEditor.style.top  = `${top}px`;

  setTimeout(()=>textInput.focus(),0);
}
textSizeEditor.addEventListener("change", ()=>{
  const s = parseInt(textSizeEditor.value,10);
  defaultTextSize = s;
  if (textDraft) textDraft.size = s;
});
textStyleEditor.addEventListener("change", ()=>{
  const st = textStyleEditor.value;
  defaultTextStyle = st;
  if (textDraft) textDraft.style = st;
});
function cancelTextEdit(){ textEditor.style.display="none"; textDraft=null; }
function commitTextEdit(){
  if (!textDraft){ textEditor.style.display="none"; return; }
  const raw = (textInput.value||"").trim();
  const L = layers[textDraft.layer];
  if (!raw){ cancelTextEdit(); return; }

  pushUndo(textDraft.layer);

  const action = {
    type:"text",
    x:textDraft.x, y:textDraft.y,
    raw,
    size:textDraft.size || defaultTextSize,
    style:textDraft.style || defaultTextStyle,
    w:null, h:null
  };

  if (textDraft.actionIndex==null) L.actions.push(action);
  else L.actions[textDraft.actionIndex] = action;

  cancelTextEdit();
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   Pointer routing
   ===================== */
function positionPopup(el, anchorEl, prefer="right"){
  if (!el || !anchorEl) return;
  const ar = anchorEl.getBoundingClientRect();
  // place below anchor, aligned to right edge by default
  const top = ar.bottom + 6;
  let left = ar.right - el.offsetWidth;
  if (prefer==="left") left = ar.left;
  // clamp to viewport
  left = clamp(left, 8, window.innerWidth - el.offsetWidth - 8);
  const maxTop = window.innerHeight - el.offsetHeight - 8;
  el.style.top = clamp(top, 8, maxTop) + "px";
  el.style.left = left + "px";
}
function closePopups(){
  closeFixedPopup(palette);
  closeFixedPopup(layersMenu);
}

function openFixedPopup(popupEl, anchorEl){
  if (!popupEl || !anchorEl) return;

  // Detach to <body> so it won't be clipped by the scrollable toolbar
  if (!popupEl.__origParent){
    popupEl.__origParent = popupEl.parentNode;
    popupEl.__origNext = popupEl.nextSibling;
  }
  if (popupEl.parentNode !== document.body){
    document.body.appendChild(popupEl);
  }

  popupEl.style.position = "fixed";
  popupEl.style.zIndex = "999999";
  popupEl.classList.add("open");

  // Prevent clicks inside popup from affecting UI underneath,
  // but DO allow the actual control inside the popup (swatch/menu item) to receive the event.
  if (!popupEl.__stopperAdded){
    popupEl.addEventListener("pointerdown", (ev)=>{ ev.stopPropagation(); }, false);
    popupEl.addEventListener("click", (ev)=>{ ev.stopPropagation(); }, false);
    popupEl.__stopperAdded = true;
  }

  // Wait for layout so we can measure the popup
  requestAnimationFrame(()=>{
    const ar = anchorEl.getBoundingClientRect();
    const pr = popupEl.getBoundingClientRect();

    // Prefer right-aligned to the anchor
    let left = ar.right - pr.width;
    let top  = ar.bottom + 6;

    // Keep on screen
    left = clamp(left, 8, window.innerWidth - pr.width - 8);
    if (top + pr.height > window.innerHeight - 8){
      top = ar.top - pr.height - 6;
    }
    top = clamp(top, 8, window.innerHeight - pr.height - 8);

    popupEl.style.left = `${Math.round(left)}px`;
    popupEl.style.top  = `${Math.round(top)}px`;
  });
}

function closeFixedPopup(popupEl){
  if (!popupEl) return;
  popupEl.classList.remove("open");
  popupEl.style.left = "";
  popupEl.style.top = "";
  popupEl.style.position = "";
  popupEl.style.zIndex = "";

  // Restore to original parent
  if (popupEl.__origParent){
    try{
      if (popupEl.__origNext && popupEl.__origNext.parentNode === popupEl.__origParent){
        popupEl.__origParent.insertBefore(popupEl, popupEl.__origNext);
      } else {
        popupEl.__origParent.appendChild(popupEl);
      }
    }catch(e){}
  }
}

function stopEvent(ev){
  ev.preventDefault();
  ev.stopPropagation();
  if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
}


function positionPalette(){
  if (!palette || !colorSelect) return;
  const r = colorSelect.getBoundingClientRect();
  const pr = palette.getBoundingClientRect();
  // place below the control, aligned to right edge of toolbar
  let left = r.right - pr.width;
  let top  = r.bottom + 6;
  left = clamp(left, 8, window.innerWidth - pr.width - 8);
  top  = clamp(top, 8, window.innerHeight - pr.height - 8);
  palette.style.left = left + "px";
  palette.style.top  = top + "px";
}

function positionLayersMenu(){
  if (!layersMenu || !layersSelect) return;
  const r = layersSelect.getBoundingClientRect();
  const mr = layersMenu.getBoundingClientRect();
  let left = r.right - mr.width;
  let top  = r.bottom + 6;
  left = clamp(left, 8, window.innerWidth - mr.width - 8);
  top  = clamp(top, 8, window.innerHeight - mr.height - 8);
  layersMenu.style.left = left + "px";
  layersMenu.style.top  = top + "px";
}
function isPointerOverUIClient(cx,cy){
  const r = ui.getBoundingClientRect();
  return cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom;
}
function pointerToCanvasXY(ev){
  const rect = ev.target.getBoundingClientRect();
  const sx = ev.clientX - rect.left;
  const sy = ev.clientY - rect.top;
  const z = zoomLevel || 1;
  return { x: sx / z, y: sy / z };
}


/* =====================
   Start / extend / finish action
   ===================== */
function startAction(x,y,pressure,pointerType){
  closePopups();
  clearHoldAlignTimer();
  lastSignificantMoveAt = performance.now();
  lastMovePos = {x,y};

  hideMeasureBox();

  if (tool==="pointer") return;

  if (tool==="pan"){
    panState.active = true;
    panState.start = {x, y};
    panState.last = {x, y};
    panState.dx = 0; panState.dy = 0;
    return;
  }

  if (tool==="text"){
    clearSelection();
    openTextEditor(x,y,"",defaultTextSize,defaultTextStyle,null,activeLayer);
    return;
  }

  if (tool==="fill"){
    clearSelection();
    pushUndo(activeLayer);
    const a = alphaFromTransp(transp);
    const ok = floodFillOnLayer(activeLayer, x, y, currentColor, a);
    if (ok){
      layers[activeLayer].actions.push({type:"fill", x, y, color: currentColor, alpha: a});
      rebuildTextOverlay();
      saveToStorage(slideKey);
    }
    return;
  }


  if (tool==="lasso"){
    if (lasso.selectedIdx.length && pointInBBox(x,y,lasso.bbox)){
      pushUndo(activeLayer);
      lasso.mode="move";
      lasso.moveStart={x,y};
      return;
    }
    clearSelection();
    lasso.selecting=true;
    lasso.points=[{x,y}];
    return;
  }

  if (tool==="laser"){
    const p0=quantizePoint(snapPoint(x,y));
    laserTrail.push({x:p0.x,y:p0.y,t:millis()});
    current={type:"laser"};
    return;
  }

  clearSelection();

  let p0=quantizePoint(snapPoint(x,y));
  if (tool==="coord1" || tool==="coord2" || tool==="coord3") p0 = quantizePoint(snapPointForced(x,y));
  const layerIndex=activeLayer;

  if (tool==="highlighter"){
    strokeWidth = 20;
    transp = 7;
    strokeWidthSel.value = String(strokeWidth);
    transpSel.value = String(transp);
    updateStrokeSelectLabel();
    updateTranspSelectLabel();

    pushUndo(layerIndex);
    const alpha = alphaFromTransp(transp);
    current={ type:"line", style:{ eraser:false, weight:strokeWidth, color:"#FFFF00", alpha }, a:p0, b:p0, layer:layerIndex };
    return;
  }

  if (tool==="pen" || tool==="eraser"){
    pushUndo(layerIndex);
    const style=makeStyleForCurrent(pressure,pointerType);
    current = { type:"path", style:{...style, weight:undefined}, points:[{x:p0.x,y:p0.y,p:pressure||1}], layer:layerIndex, pointerType };
    return;
  }

  if (["line","arrow","circle","rect","shadowRect","rightTri","titleBox","coord1","coord2","coord3","ellipse","ellipse99"].includes(tool)) pushUndo(layerIndex);

  const style=makeStyleForCurrent(pressure,pointerType);
  if (tool==="line") current={type:"line", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="arrow") current={type:"arrow", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="circle") current={type:"circle", style:style, c:p0, r:0, layer:layerIndex};
  if (tool==="rect") current={type:"rect", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="shadowRect") current={type:"shadowRect", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="titleBox") current={type:"titleBox", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="rightTri") current={type:"rightTri", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="coord1" || tool==="coord2" || tool==="coord3") {
    coordSnapRestore.prev = snapToGrid;
    coordSnapRestore.active = true;
    snapToGrid = true; if (snapEl) snapEl.checked = true;
    current={type:tool, style:style, a:p0, b:p0, layer:layerIndex};
  }
  if (tool==="ellipse") current={type:"ellipse", e:0.9, style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="ellipse99") current={type:"ellipse", e:0.99, style:style, a:p0, b:p0, layer:layerIndex};
}

function extendAction(x,y,pressure,pointerType){
  if (tool==="pan"){
    if (!panState.active) return;
    const dx = x - panState.last.x;
    const dy = y - panState.last.y;
    panState.last = {x, y};
    panState.dx += dx; panState.dy += dy;
    if (dx || dy){
      for (let li=0; li<3; li++){
        for (const a of layers[li].actions) translateAction(a, dx, dy);
      }
      rebuildAllBuffers();
      rebuildTextOverlay();
    }
    return;
  }
  if (tool==="lasso"){
    if (lasso.mode==="move" && lasso.moveStart){
      const dx = x - lasso.moveStart.x;
      const dy = y - lasso.moveStart.y;
      const L = layers[activeLayer];
      for(const idx of lasso.selectedIdx) translateAction(L.actions[idx], dx, dy);
      lasso.moveStart = {x,y};
      recomputeSelectionBBox();
      rebuildLayerBuffer(activeLayer);
      rebuildTextOverlay();
      return;
    }
    if (lasso.selecting){
      const last=lasso.points[lasso.points.length-1];
      if (dist(last.x,last.y,x,y)<2) return;
      lasso.points.push({x,y});
      return;
    }
    return;
  }

  if (!current) return;

  const p = (current.type==="coord1" || current.type==="coord2" || current.type==="coord3")
    ? quantizePoint(snapPointForced(x,y))
    : quantizePoint(snapPoint(x,y));

  if (current.type==="laser"){
    laserTrail.push({x:p.x,y:p.y,t:millis()});
    return;
  }

  const now = performance.now();
  const still = isStill(now, p.x, p.y);
  if (still && !holdAlignTimer) armHoldAlignTimer();

  if (current.type==="line" || current.type==="arrow"){
    current.b = p;
    if (isShiftDown){
      maybeAlignLineLike(current);
      clearHoldAlignTimer();
    }
    updateMeasureForCurrentShape();
    return;
  }

  if (current.type==="path"){
    hideMeasureBox();
    const pts=current.points;
    const last=pts[pts.length-1];
    if (dist(last.x,last.y,p.x,p.y) < 0.8) return;

    const sm = current.style.smoothing || 1;
    const a = (sm<=1)?1:(2/(sm+1));
    const nx = last.x + a*(p.x-last.x);
    const ny = last.y + a*(p.y-last.y);
    pts.push({x:nx,y:ny,p:(pressure ?? 1)});
    return;
  }

  if (["rect","shadowRect","rightTri","titleBox","coord1","coord2","coord3","ellipse"].includes(current.type)) current.b = p;
  if (current.type==="circle") current.r = quantizeScalar(dist(current.c.x,current.c.y,p.x,p.y));

  updateMeasureForCurrentShape();
}

function finishAction(){
  clearHoldAlignTimer();
  hideMeasureBox();

  if (tool==="pan"){
    if (!panState.active) return;

    // Snap final translation to multiples of the background grid spacing
    const sdx = Math.round(panState.dx / GRID_STEP) * GRID_STEP;
    const sdy = Math.round(panState.dy / GRID_STEP) * GRID_STEP;
    const cx = sdx - panState.dx;
    const cy = sdy - panState.dy;

    // Track snapped pan offset for Reset
    panOffsetTotal.x += sdx;
    panOffsetTotal.y += sdy;

    if (cx || cy){
      for (let li=0; li<3; li++){
        for (const a of layers[li].actions) translateAction(a, cx, cy);
      }
      rebuildAllBuffers();
      rebuildTextOverlay();
    }

    panState.active = false;
    panState.dx = 0; panState.dy = 0;
    saveToStorage(slideKey);
    return;
  }

  if (tool==="lasso"){
    if (lasso.mode==="move"){
      lasso.mode="idle";
      lasso.moveStart=null;
      rebuildLayerBuffer(activeLayer);
      rebuildTextOverlay();
      saveToStorage(slideKey);
      return;
    }
    if (lasso.selecting){
      lasso.selecting=false;
      lassoSelect();
      return;
    }
    return;
  }

  if (!current) return;
  if (current.type==="laser"){ current=null; return; }

  const L=layers[current.layer];

  if (current.type==="path"){
    L.actions.push({ type:"path", style: current.style, points: current.points });

    const a = L.actions[L.actions.length-1];
    const pts=a.points;
    for (let k=1;k<pts.length;k++){
      const p0=pts[k-1], p1=pts[k];
      const avgP=((p0.p??1)+(p1.p??1))/2;
      const mult=pressureMultiplier(avgP, "pen");
      const w=(a.style.baseWeight||2)*mult;

      if (a.style.eraser){
        L.pg.erase();
        L.pg.stroke(0); L.pg.strokeWeight(w);
        L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
        L.pg.line(p0.x,p0.y,p1.x,p1.y);
        L.pg.noErase();
      } else {
        const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
        L.pg.stroke(col); L.pg.strokeWeight(w);
        L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
        L.pg.line(p0.x,p0.y,p1.x,p1.y);
      }
    }
  } else {
    if (current.type==="line" || current.type==="arrow" || current.type==="rect" || current.type==="shadowRect" || current.type==="titleBox" || current.type==="rightTri" || (current.type==="coord1"||current.type==="coord2"||current.type==="coord3") || current.type==="ellipse" || current.type==="ellipse99"){
      current.a = quantizePoint(current.a);
      current.b = quantizePoint(current.b);
    }
    if (current.type==="circle"){
      current.c = quantizePoint(current.c);
      current.r = quantizeScalar(current.r || 0);
    }

    L.pg.push();
    drawShapeAction(current, L.pg);
    L.pg.pop();
    L.actions.push(current);
  }

  current=null;

  if (coordSnapRestore.active){
    snapToGrid = coordSnapRestore.prev;
    if (snapEl) snapEl.checked = snapToGrid;
    coordSnapRestore.active = false;
  }

  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   Pointer events
   ===================== */
function onPointerDown(ev){
  ev.preventDefault();
  lastPointerClient = {x: ev.clientX, y: ev.clientY};

  if (Date.now() < suppressCanvasUntil) return;

  if (textEditor.style.display!=="none" && !textEditor.contains(ev.target)) commitTextEdit();
  if (isPointerOverUIClient(ev.clientX, ev.clientY)) return;

  pointerDown=true;
  activePointerId=ev.pointerId;
  activePointerType=ev.pointerType||"mouse";
  lastPressure=(typeof ev.pressure==="number") ? ev.pressure : 1;

  const {x,y} = pointerToCanvasXY(ev);
  startAction(x,y,lastPressure,activePointerType);
}
function onPointerMove(ev){
  lastPointerClient = {x: ev.clientX, y: ev.clientY};
  if(!pointerDown || ev.pointerId!==activePointerId) return;
  ev.preventDefault();
  lastPressure=(typeof ev.pressure==="number") ? ev.pressure : lastPressure;
  const {x,y} = pointerToCanvasXY(ev);
  extendAction(x,y,lastPressure,activePointerType);
}
function onPointerUp(ev){
  lastPointerClient = {x: ev.clientX, y: ev.clientY};
  if(!pointerDown || ev.pointerId!==activePointerId) return;
  ev.preventDefault();
  finishAction();

  pointerDown=false;
  activePointerId=null;
  activePointerType="mouse";
  lastPressure=1;
}

/* =====================
   Keyboard shortcuts
   ===================== */
function clearActiveLayer(){
  clearSelection();
  pushUndo(activeLayer);
  layers[activeLayer].actions = [];
  layers[activeLayer].pg.clear();
  rebuildLayerBuffer(activeLayer);
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

function onKeyDown(ev){
  if (ev.key === "Shift") isShiftDown = true;

  if (ev.key === "Escape"){
    if (textEditor.style.display!=="none") cancelTextEdit();
    clearSelection();
    setTool("pointer");
    return;
  }
  if (textEditor.style.display!=="none") return;

  const k = ev.key.toLowerCase();

  // Export shortcuts (only when not embedded)
  if (!EMBEDDED && (ev.ctrlKey||ev.metaKey)){
    if (k==="p") { ev.preventDefault(); exportPNGCurrentSlide(); return; }
    if (k==="s") { ev.preventDefault(); saveAllAnnotationsJSON(); return; }
    if (k==="o") { ev.preventDefault(); openAllAnnotationsJSON(); return; }
  }

  // Smoothness shortcuts (Ctrl+1..9)
  if ((ev.ctrlKey||ev.metaKey) && /^[1-9]$/.test(k)){
    ev.preventDefault();
    const sm = parseInt(k,10);
    smoothing = sm;
    if (smoothingSel) smoothingSel.value = String(smoothing);
    updateSmoothingSelectLabel();
    if (tool!=="highlighter" && tool!=="laser" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
    saveToStorage(slideKey);
    showCursorHintWithColor(`Smooth ${smoothing}/10`, currentColor);
    return;
  }


  // Cycle basic colors (top row only) (C)
  if (k==="c"){
    const top = COLORS.slice(0,6);
    const i = Math.max(0, top.indexOf(currentColor));
    currentColor = top[(i+1) % top.length];
    if (colorChip) colorChip.style.background = currentColor;

    if (tool==="laser"){
      laserPrefs = { color: currentColor, width: strokeWidth, transp };
    } else if (tool!=="highlighter" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
    saveToStorage(slideKey);
    showCursorHintWithColor("Color", currentColor);
    return;
  }

  // Toggle shortcuts box (K) (not listed in the shortcut list)
  if (k==="k"){
    toggleShortcutsBox();
    return;
  }

  // Expand/collapse toolbar (X)
  if (k==="x"){
    collapseState = (collapseState==="collapsed") ? "expanded" : "collapsed";
    applyCollapseState();
    return;
  }
  if ((ev.ctrlKey||ev.metaKey) && k==="d"){
    ev.preventDefault();
    clearActiveLayer();
    return;
  }

  if (!EMBEDDED && (ev.ctrlKey||ev.metaKey) && k==="f"){
    ev.preventDefault();
    exportPDFCurrentSlide();
    return;
  }

  if (/^[1-9]$/.test(k)){
    const idx = parseInt(k,10) - 1;
    const vals=[1,2,3,4,5,8,10,20,30];
    const v = vals[idx] ?? vals[vals.length-1];
    strokeWidth = v;
    if (tool!=="eraser" && tool!=="highlighter" && tool!=="laser") lastNonEraserWidth = v;
    strokeWidthSel.value = String(v);
    updateStrokeSelectLabel();
    penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    return;
  }

  // Cycle stroke width (W)
  if (k==="w"){
    const vals=[1,2,3,4,5,8,10,20,30];
    const i = Math.max(0, vals.indexOf(strokeWidth));
    strokeWidth = vals[(i+1) % vals.length];
    if (tool!=="eraser" && tool!=="highlighter" && tool!=="laser") lastNonEraserWidth = strokeWidth;
    if (strokeWidthSel) strokeWidthSel.value = String(strokeWidth);
    updateStrokeSelectLabel();
    if (tool==="laser"){
      laserPrefs.width = strokeWidth;
    } else if (tool!=="highlighter" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
    showCursorHintWithColor(`Width ${strokeWidth} pt`, currentColor);
    return;
  }

  // Transparency cycle (Q)
  if (k==="q"){
    transp = (transp % 10) + 1;
    if (transpSel) transpSel.value = String(transp);
    updateTranspSelectLabel();
    if (tool==="laser"){
      laserPrefs.transp = transp;
    } else if (tool!=="highlighter" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
    saveToStorage(slideKey);
    showCursorHintWithColor(`Transp. ${transp}/10`, currentColor);
    return;
  }
  // Smoothness cycle (A)
  if (k==="a"){
    smoothing = (smoothing % 10) + 1;
    if (smoothingSel) smoothingSel.value = String(smoothing);
    updateSmoothingSelectLabel();
    if (tool!=="highlighter" && tool!=="laser" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
    saveToStorage(slideKey);
    showCursorHintWithColor(`Smooth. ${smoothing}/10`, currentColor);
    return;
  }

  // Pan (M)
  if (k==="m"){
    setTool("pan");
    showCursorHint("Move canvas");
    return;
  }

  // Zoom in/out (Z/U)
  if (k==="z"){
    zoomLevel = Math.min(3, zoomLevel * 1.1);
    applyZoom();
    return;
  }
  if (k==="u"){
    zoomLevel = Math.max(0.25, zoomLevel / 1.1);
    applyZoom();
    return;
  }

  // Reset view (R)
  if (k==="r"){
    resetView();
    return;
  }

  if (k==="p") setTool("pen");
  if (k==="e") setTool("eraser");
  if (k==="h") setTool("highlighter");
  if (k==="o") setTool("laser");
  if (k==="l") setTool("lasso");
  if (k==="t") setTool("text");
  if (k==="f") setTool("fill");

  if (k==="s"){
    shapeIndex = (shapeIndex + 1) % SHAPES.length;
    const sh = SHAPES[shapeIndex];
    shapeToolSel.value = sh;
    setTool(sh);
    showCursorHintWithColor(`Shapes: ${sh}`, currentColor);
  }

  if (k==="g"){
    bgMode = (bgMode==="transparent") ? "dots" : (bgMode==="dots") ? "grid" : "transparent";
    bgModeSel.value = bgMode;
    saveToStorage(slideKey);
  }

  if (k==="n"){
    snapToGrid = !snapToGrid;
    snapEl.checked = snapToGrid;
  }

  if (k==="y"){
    activeLayer = (activeLayer + 1) % 3;
    clearSelection();
    updateLayersLabel();
    rebuildLayersMenu();
    saveToStorage(slideKey);
    showToast(`Layer ${activeLayer+1}`, 900);
  }

  if ((ev.ctrlKey||ev.metaKey) && k==="z"){
    ev.preventDefault();
    undoActiveLayer();
  }

  if (lasso.selectedIdx.length && (ev.key==="Delete" || ev.key==="Backspace")){
    ev.preventDefault();
    deleteSelection();
  }
}

/* =====================
   UI
   ===================== */
let ui, dragHandle;
let btnCycle, glyphCycle, btnPointer, btnPan;

let utilRow, btnZoomIn, btnZoomOut, btnZoomReset;

let exportRow, btnPNG, btnPDF, btnSave, btnOpen;

let toolPenBtn, toolEraserBtn, toolLaserBtn, toolHighlighterBtn, toolTextBtn, toolFillBtn, toolLassoBtn;
let shapeToolSel;
let bgModeSel, strokeWidthSel, smoothingSel, transpSel;
let snapEl, undoBtn, clearBtn;

let colorSelect, palette, paletteGrid, colorChip;
let layersSelect, layersMenu, layersLabel;

let collapseState = "collapsed";

function initUI(){
  ui=document.getElementById("ui");
  dragHandle=document.getElementById("dragHandle");

  btnCycle=document.getElementById("btnCycle");
  glyphCycle=document.getElementById("glyphCycle");
  btnPointer=document.getElementById("btnPointer");
  btnPan=document.getElementById("btnPan");

  utilRow=document.getElementById("utilRow");
  btnZoomOut=document.getElementById("btnZoomOut");
  btnZoomIn=document.getElementById("btnZoomIn");
  btnZoomReset=document.getElementById("btnZoomReset");

  exportRow=document.getElementById("exportRow");
  btnPNG=document.getElementById("btnPNG");
  btnPDF=document.getElementById("btnPDF");
  btnSave=document.getElementById("btnSave");
  btnOpen=document.getElementById("btnOpen");

  toolPenBtn=document.getElementById("toolPen");
  toolEraserBtn=document.getElementById("toolEraser");
  toolHighlighterBtn=document.getElementById("toolHighlighter");
  toolFillBtn=document.getElementById("toolFill");
  toolTextBtn=document.getElementById("toolText");
  toolLaserBtn=document.getElementById("toolLaser");
  toolLassoBtn=document.getElementById("toolLasso");

  shapeToolSel=document.getElementById("shapeTool");

  bgModeSel=document.getElementById("bgMode");
  strokeWidthSel=document.getElementById("strokeWidth");
  smoothingSel=document.getElementById("smoothing");
  transpSel=document.getElementById("transp");
  snapEl=document.getElementById("snap");

  colorSelect=document.getElementById("colorSelect");
  palette=document.getElementById("palette");
  paletteGrid=document.getElementById("paletteGrid");
  colorChip=document.getElementById("colorChip");

  layersSelect=document.getElementById("layersSelect");
  layersMenu=document.getElementById("layersMenu");

  // Portal popups to <body> so they're never clipped by the scrollable toolbar
  if (palette && palette.parentElement !== document.body) document.body.appendChild(palette);
  if (layersMenu && layersMenu.parentElement !== document.body) document.body.appendChild(layersMenu);

  layersLabel=document.getElementById("layersLabel");

  undoBtn=document.getElementById("undo");
  clearBtn=document.getElementById("clear");

  // hide export row + disable export shortcuts when embedded
  if (EMBEDDED){
    exportRow.style.display = "none";
  }

  btnPan.addEventListener("click",(ev)=>{ ev.preventDefault(); setTool("pan"); });

  btnPointer.addEventListener("click",(ev)=>{
    ev.preventDefault();
    setTool("pointer");
  });

  // palette
  paletteGrid.innerHTML="";
  COLORS.forEach(hex=>{
    const sw = document.createElement("div");
    sw.className="swatch";
    sw.style.background=hex;
    sw.addEventListener("pointerdown",(ev)=>{ ev.preventDefault();
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation();
      currentColor=hex;
      colorChip.style.background=hex;
      palette.classList.remove("open");

      if (tool==="laser"){
        laserPrefs = { color: currentColor, width: strokeWidth, transp };
      } else if (tool!=="highlighter" && tool!=="eraser"){
        penState = { color: currentColor, width: strokeWidth, transp, smoothing };
      }
      saveToStorage(slideKey);
    });

    // Prevent click/tap from "falling through" to underlying controls
    sw.addEventListener("pointerup",(ev)=>{ ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); });
    sw.addEventListener("click",(ev)=>{ ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); });
    sw.addEventListener("pointerup",(ev)=>{ ev.preventDefault(); ev.stopPropagation(); });
    paletteGrid.appendChild(sw);
  });
  colorChip.style.background=currentColor;

  document.addEventListener("pointerdown",(ev)=>{
    if(!colorSelect.contains(ev.target)) palette.classList.remove("open");
    if(!layersSelect.contains(ev.target)) layersMenu.classList.remove("open");
    const bs = document.getElementById("btnShortcuts");
    if (shortcutsVisible && shortcutBox && !shortcutBox.contains(ev.target) && bs && !bs.contains(ev.target)) hideShortcutsBox();
  }, {capture:true});

  colorSelect.addEventListener("pointerdown",(ev)=>{
    ev.stopPropagation();
    layersMenu.classList.remove("open");
    if (palette.classList.contains("open")) palette.classList.remove("open");
    else openFixedPopup(palette, colorSelect);
  });
  layersSelect.addEventListener("pointerdown",(ev)=>{
    ev.stopPropagation();
    palette.classList.remove("open");
    if (layersMenu.classList.contains("open")) layersMenu.classList.remove("open");
    else openFixedPopup(layersMenu, layersSelect);
  });

  // collapse toggle
  btnCycle.addEventListener("click",(ev)=>{
    ev.stopPropagation();
    collapseState = (collapseState==="collapsed") ? "expanded" : "collapsed";
    applyCollapseState();
  });
  function updateCycleGlyph(){
    glyphCycle.textContent = (collapseState==="expanded") ? "‚ñ¥" : "‚ñæ";
  }
  function applyCollapseState(){
    ui.classList.toggle("collapsed", collapseState==="collapsed");
    if (collapseState==="collapsed") closePopups();
    updateCycleGlyph();
    if (shortcutsVisible) positionShortcutBox();
    if (palette && palette.classList.contains("open")) positionPalette();
    if (layersMenu && layersMenu.classList.contains("open")) positionLayersMenu();
    if (palette && palette.classList.contains("open")) positionPalette();
    if (layersMenu && layersMenu.classList.contains("open")) positionLayersMenu();
  }
  window.applyCollapseState = applyCollapseState;
  applyCollapseState();

  // tools
  toolPenBtn.addEventListener("click",()=> setTool("pen"));
  toolEraserBtn.addEventListener("click",()=> setTool("eraser"));
  toolHighlighterBtn.addEventListener("click",()=> setTool("highlighter"));
  toolFillBtn.addEventListener("click",()=> setTool("fill"));
  toolTextBtn.addEventListener("click",()=> setTool("text"));
  toolLaserBtn.addEventListener("click",()=> setTool("laser"));
  toolLassoBtn.addEventListener("click",()=> setTool("lasso"));

  // Shapes dropdown behavior:
  shapeToolSel.addEventListener("input",()=> setTool(shapeToolSel.value));
  shapeToolSel.addEventListener("change",()=> setTool(shapeToolSel.value));
  shapeToolSel.addEventListener("pointerup",()=>{
    if (shapeToolSel.value) setTool(shapeToolSel.value);
  });

  bgModeSel.addEventListener("change",()=>{ bgMode=bgModeSel.value; saveToStorage(slideKey); });

  buildStrokeSelect();
  buildSmoothingSelect();
  buildTranspSelect();

  snapEl.checked=snapToGrid;
  snapEl.addEventListener("change",()=>{ snapToGrid=snapEl.checked; });

  undoBtn.addEventListener("click",()=>{ clearSelection(); undoActiveLayer(); });
  clearBtn.addEventListener("click",()=> clearActiveLayer());

  rebuildLayersMenu();
  updateLayersLabel();

  initDrag();

  initTouchScroll();

  // Prevent UI interactions (e.g. open/save dialogs) from triggering a stray canvas action
  ui.addEventListener("pointerdown",(ev)=>{
    if (ev.target.closest("#ui")) suppressCanvasUntil = Date.now() + 350;
  }, true);

  document.getElementById("btnShortcuts").addEventListener("click",(e)=>{ e.preventDefault(); e.stopPropagation(); toggleShortcutsBox(); });
  shortcutBox.addEventListener("click",(e)=>{ e.preventDefault(); hideShortcutsBox(); });

  // ensure arrow is default selected in dropdown
  shapeToolSel.value = "arrow";
  tool = "pointer";
  // Zoom controls
  btnZoomIn.addEventListener("click", (e)=>{ e.preventDefault(); zoomLevel = clamp(zoomLevel * 1.2, 0.5, 3); applyZoom(); showToast(`Zoom ${Math.round(zoomLevel*100)}%`, 900); });
  btnZoomOut.addEventListener("click", (e)=>{ e.preventDefault(); zoomLevel = clamp(zoomLevel / 1.2, 0.5, 3); applyZoom(); showToast(`Zoom ${Math.round(zoomLevel*100)}%`, 900); });
  btnZoomReset.addEventListener("click", (e)=>{ e.preventDefault(); resetView(); });



  // Export actions (only when not embedded)
  if (!EMBEDDED){
    btnPNG.addEventListener("click", (e)=>{ e.preventDefault(); exportPNGCurrentSlide(); });
    btnPDF.addEventListener("click", async (e)=>{ e.preventDefault(); await exportPDFCurrentSlide(); });
    btnSave.addEventListener("click", (e)=>{ e.preventDefault(); saveAllAnnotationsJSON(); });
    btnOpen.addEventListener("click", (e)=>{ e.preventDefault(); openAllAnnotationsJSON(); });
  }
}

function buildStrokeSelect(){
  strokeWidthSel.innerHTML="";
  const vals=[1,2,3,4,5,8,10,20,30];
  for (const v of vals){
    const o=document.createElement("option");
    o.value=String(v);
    o.textContent = `${v} pt`;
    if (v===strokeWidth) o.selected=true;
    strokeWidthSel.appendChild(o);
  }
  updateStrokeSelectLabel();
  strokeWidthSel.addEventListener("change",()=>{
    strokeWidth=parseInt(strokeWidthSel.value,10);
    if (tool==="laser"){
      laserPrefs.width = strokeWidth;
    } else if (tool!=="eraser" && tool!=="highlighter"){
      lastNonEraserWidth=strokeWidth;
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
  });
}
function updateStrokeSelectLabel(){
  const opt = strokeWidthSel.options[strokeWidthSel.selectedIndex];
  opt.textContent = `‚Üï Width ${strokeWidthSel.value} pt`;
  for (const o of strokeWidthSel.options){
    if (o !== opt) o.textContent = `${o.value} pt`;
  }
}
function buildSmoothingSelect(){
  smoothingSel.innerHTML="";
  for (let v=1; v<=10; v++){
    const o=document.createElement("option");
    o.value=String(v);
    o.textContent = `${v}`;
    if (v===smoothing) o.selected=true;
    smoothingSel.appendChild(o);
  }
  updateSmoothingSelectLabel();
  smoothingSel.addEventListener("change",()=>{
    smoothing=parseInt(smoothingSel.value,10);
    updateSmoothingSelectLabel();
    if (tool!=="highlighter" && tool!=="laser" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
  });
}
function updateSmoothingSelectLabel(){
  const opt = smoothingSel.options[smoothingSel.selectedIndex];
  opt.textContent = `‚âà Smooth. ${smoothingSel.value}/10`;
  for (const o of smoothingSel.options){
    if (o !== opt) o.textContent = `${o.value}`;
  }
}
function buildTranspSelect(){
  transpSel.innerHTML="";
  for (let v=1; v<=10; v++){
    const o=document.createElement("option");
    o.value=String(v);
    o.textContent = `${v}`;
    if (v===transp) o.selected=true;
    transpSel.appendChild(o);
  }
  updateTranspSelectLabel();
  transpSel.addEventListener("change",()=>{
    transp=parseInt(transpSel.value,10);
    updateTranspSelectLabel();

    if (tool==="laser"){
      laserPrefs.transp = transp;
    } else if (tool!=="highlighter" && tool!=="eraser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
  });
}
function updateTranspSelectLabel(){
  const opt = transpSel.options[transpSel.selectedIndex];
  opt.textContent = `‚óå Transp. ${transpSel.value}/10`;
  for (const o of transpSel.options){
    if (o !== opt) o.textContent = `${o.value}`;
  }
}

function setTool(t){
  if(!t) t="pointer";
  let restoredFromSpecial = false;
  if (textEditor.style.display!=="none") commitTextEdit();
  clearHoldAlignTimer();
  hideMeasureBox();

  const goingToSpecial = (t==="highlighter" || t==="laser");
  if (goingToSpecial){
    if (tool!=="highlighter" && tool!=="laser"){
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    }
  }

  const fromSpecial = (tool==="highlighter" || tool==="laser");
  const isPenOrShape = (t==="pen" || ["line","arrow","circle","rect","shadowRect","rightTri","titleBox","coord1","coord2","coord3","ellipse","ellipse99"].includes(t));
  if (isPenOrShape && fromSpecial){
    restoredFromSpecial = true;
    currentColor = penState.color;
    strokeWidth  = penState.width;
    transp       = penState.transp;
    smoothing    = penState.smoothing;
    lastNonEraserWidth = penState.width;

    colorChip.style.background = currentColor;
    strokeWidthSel.value = String(strokeWidth);
    smoothingSel.value = String(smoothing);
    transpSel.value = String(transp);
    updateStrokeSelectLabel();
    updateSmoothingSelectLabel();
    updateTranspSelectLabel();
  }

  tool=t;
  current=null;

  toolPenBtn.classList.toggle("active", tool==="pen");
  toolEraserBtn.classList.toggle("active", tool==="eraser");
  toolHighlighterBtn.classList.toggle("active", tool==="highlighter");
  toolFillBtn.classList.toggle("active", tool==="fill");
  toolTextBtn.classList.toggle("active", tool==="text");
  toolLaserBtn.classList.toggle("active", tool==="laser");
  toolLassoBtn.classList.toggle("active", tool==="lasso");

  if (btnPan) btnPan.classList.toggle("active", tool==="pan");
  if (btnPointer) btnPointer.classList.toggle("active", tool==="pointer");

  if (tool==="laser"){
    if (!laserEverUsed){
      laserEverUsed = true;
      laserPrefs = { color:"#D7263D", width:2, transp:7 };
    }
    currentColor = laserPrefs.color;
    strokeWidth  = laserPrefs.width;
    transp       = laserPrefs.transp;

    colorChip.style.background = currentColor;
    transpSel.value = String(transp);
    strokeWidthSel.value = String(strokeWidth);

    updateTranspSelectLabel();
    updateStrokeSelectLabel();
  }

  if (tool==="highlighter"){
    strokeWidth = 20;
    transp = 7;
    strokeWidthSel.value = String(strokeWidth);
    transpSel.value = String(transp);
    updateStrokeSelectLabel();
    updateTranspSelectLabel();
  }

  if (tool==="eraser"){
    strokeWidth=10;
  } else if (!restoredFromSpecial && tool!=="highlighter" && tool!=="laser" && tool!=="pointer" && tool!=="text" && tool!=="fill" && tool!=="lasso") {
    strokeWidth = lastNonEraserWidth ?? strokeWidth ?? 2;
  }

  strokeWidthSel.value = String(strokeWidth);
  smoothingSel.value = String(smoothing);
  transpSel.value = String(transp);
  updateStrokeSelectLabel();
  updateSmoothingSelectLabel();
  updateTranspSelectLabel();

  const boxes = textOverlay.querySelectorAll(".text-box");
  boxes.forEach(b=>{
    b.style.pointerEvents = (tool==="text" || tool==="pointer") ? "auto" : "none";
    b.classList.toggle("draggable", tool==="pointer");
  });

  rebuildTextOverlay();
}

/* draggable toolbar */
function initDrag(){
  let dragging=false, startX=0,startY=0,startLeft=0,startTop=0;

  dragHandle.addEventListener("pointerdown",(ev)=>{
    if (ev.target.closest("button")) return;
    dragging=true;
    dragHandle.setPointerCapture(ev.pointerId);
    startX=ev.clientX; startY=ev.clientY;
    const rect=ui.getBoundingClientRect();
    startLeft=rect.left; startTop=rect.top;
    ui.style.left=`${startLeft}px`;
    ui.style.top=`${startTop}px`;
    ui.style.right="auto";
  });

  dragHandle.addEventListener("pointermove",(ev)=>{
    if(!dragging) return;
    const dx=ev.clientX-startX, dy=ev.clientY-startY;
    const rect=ui.getBoundingClientRect();
    const w=rect.width, h=rect.height;
    let nl=clamp(startLeft+dx, 8, window.innerWidth-w-8);
    let nt=clamp(startTop+dy, 8, window.innerHeight-h-8);
    ui.style.left=`${nl}px`;
    ui.style.top=`${nt}px`;

    if (measureBox.classList.contains("show")) positionHudBox(measureBox, 14);
    if (toastBox.classList.contains("show")) positionHudBox(toastBox, 12);
    if (shortcutsVisible) positionShortcutBox();
    if (palette && palette.classList.contains("open")) positionPalette();
    if (layersMenu && layersMenu.classList.contains("open")) positionLayersMenu();
    if (palette && palette.classList.contains("open")) positionPalette();
    if (layersMenu && layersMenu.classList.contains("open")) positionLayersMenu();
  });

  dragHandle.addEventListener("pointerup",()=>{ dragging=false; });
}

/* touch-drag scroll inside toolbar (no visible scrollbar)
   - You can start the gesture even on buttons/selects.
   - A tap (no significant move) still clicks the control.
   - If you drag/hold-move, we scroll and suppress the click. */
function initTouchScroll(){
  if (!ui) return;

  let pid = null;
  let startY = 0;
  let startScroll = 0;
  let startT = 0;
  let didScroll = false;
  let suppressClick = false;
  let captured = false;

  const MOVE_PX = 7;      // move threshold to become a scroll
  const HOLD_MS = 140;    // long-press with a small move still becomes scroll

  // Cancel click events that belong to a scroll gesture
  ui.addEventListener("click", (ev)=>{
    if (!suppressClick) return;
    suppressClick = false;
    ev.preventDefault();
    ev.stopPropagation();
    ev.stopImmediatePropagation();
  }, true);

  ui.addEventListener("pointerdown", (ev)=>{
    if (dragHandle && dragHandle.contains(ev.target)) return;
    // Mouse should behave normally (click buttons). Touch/pen can drag-to-scroll.
    if (ev.pointerType === "mouse") return;

    pid = ev.pointerId;
    startY = ev.clientY;
    startScroll = ui.scrollTop;
    startT = performance.now();
    didScroll = false;
    captured = false;
    // NOTE: Do NOT capture here ‚Äî otherwise taps on buttons/selects won't fire.
    // We capture only once the gesture turns into a scroll.
  });

  ui.addEventListener("pointermove", (ev)=>{
    if (pid == null || ev.pointerId !== pid) return;

    const dy = ev.clientY - startY;
    const ady = Math.abs(dy);

    // become a scroll if user drags enough, or holds briefly and then moves
    if (!didScroll){
      if (ady >= MOVE_PX || (performance.now() - startT > HOLD_MS && ady > 2)){
        didScroll = true;
        // Capture now to keep receiving moves even when leaving the UI
        try{ ui.setPointerCapture(ev.pointerId); captured = true; }catch(e){}
      } else {
        return;
      }
    }

    ev.preventDefault();
    ui.scrollTop = startScroll - dy;

    // keep overlays aligned while scrolling
    if (shortcutsVisible) positionShortcutBox();
    if (palette && palette.classList.contains("open")) positionPalette();
    if (layersMenu && layersMenu.classList.contains("open")) positionLayersMenu();
    if (palette && palette.classList.contains("open")) positionPalette();
    if (layersMenu && layersMenu.classList.contains("open")) positionLayersMenu();
    if (measureBox && measureBox.classList.contains("show")) positionHudBox(measureBox, 14);
    if (toastBox && toastBox.classList.contains("show")) positionHudBox(toastBox, 12);
  }, {passive:false});

  const end = (ev)=>{
    if (pid == null || ev.pointerId !== pid) return;

    if (didScroll){
      // suppress the synthetic click that would trigger the underlying control
      suppressClick = true;
    }
    if (captured){
      try{ ui.releasePointerCapture(ev.pointerId); }catch(e){}
    }

    pid = null;
    didScroll = false;
    captured = false;
  };

  ui.addEventListener("pointerup", end);
  ui.addEventListener("pointercancel", end);
}



/* layers menu */
function rebuildLayersMenu(){
  layersMenu.innerHTML="";
  for (let i=0;i<3;i++){
    const item=document.createElement("div");
    item.className="layer-item" + (layers[i].visible ? "" : " invisible");

    const left=document.createElement("div");
    left.className="layer-left";

    const tick=document.createElement("div");
    tick.className="tick";
    tick.textContent=(i===activeLayer)?"‚úì":"";

    const visDot=document.createElement("div");
    visDot.className="vis-dot";

    const name=document.createElement("div");
    name.className="layer-name";
    name.textContent=`Layer ${i+1}`;

    left.appendChild(tick);
    left.appendChild(visDot);
    left.appendChild(name);

    const right=document.createElement("div");
    right.style.fontSize="12px";
    right.style.opacity="0.65";
    right.textContent=layers[i].visible ? "on" : "off";

    item.appendChild(left);
    item.appendChild(right);

    item.addEventListener("pointerdown",(ev)=>{
      ev.stopPropagation();
      if (activeLayer!==i) activeLayer=i;
      else layers[i].visible = !layers[i].visible;

      clearSelection();
      updateLayersLabel();
      rebuildLayersMenu();
      layersMenu.classList.remove("open");
      rebuildAllBuffers();
      rebuildTextOverlay();
      saveToStorage(slideKey);
    });

    item.addEventListener("click",(ev)=>{ ev.preventDefault(); ev.stopPropagation(); if (ev.stopImmediatePropagation) ev.stopImmediatePropagation(); });
    layersMenu.appendChild(item);
  }
}
function updateLayersLabel(){
  const vis = layers[activeLayer]?.visible ? "on" : "off";
  layersLabel.textContent = `üß±  Layers (${activeLayer+1}:${vis})`;
}

/* =====================
   PNG export to clipboard
   ===================== */

let __canvgReady = null;
function ensureCanvg(){
  try{
    if (window.canvg && window.canvg.Canvg) return Promise.resolve(window.canvg.Canvg);
  }catch(e){}
  if (__canvgReady) return __canvgReady;
  __canvgReady = new Promise((resolve)=>{
    const s = document.createElement("script");
    s.src = "https://cdn.jsdelivr.net/npm/canvg@3.0.10/lib/umd.min.js";
    s.async = true;
    s.onload = ()=> {
      try{
        resolve((window.canvg && window.canvg.Canvg) ? window.canvg.Canvg : null);
      }catch(e){ resolve(null); }
    };
    s.onerror = ()=> resolve(null);
    document.head.appendChild(s);
  });
  return __canvgReady;
}

// MathJax v2 SVG output frequently uses <use xlink:href="#MJX-..."> glyphs that
// are defined in a separate hidden <svg> ("MathJax_SVG_Hidden"). When exporting,
// we must inline those shared <defs> into the formula SVG, otherwise rasterizers
// (canvg/Image) will render blank.
function buildStandaloneMathJaxSVG(svgEl, targetW, targetH){
  const NS = "http://www.w3.org/2000/svg";
  const XLINK = "http://www.w3.org/1999/xlink";

  const clone = svgEl.cloneNode(true);
  clone.setAttribute("width", String(targetW));
  clone.setAttribute("height", String(targetH));
  if (!clone.getAttribute("xmlns")) clone.setAttribute("xmlns", NS);
  if (!clone.getAttribute("xmlns:xlink")) clone.setAttribute("xmlns:xlink", XLINK);

  // Make sure the export is self-contained and visible without external CSS.
  try{
    clone.setAttribute("color", "#000");
    const styleEl = document.createElementNS(NS, "style");
    styleEl.setAttribute("type", "text/css");
    styleEl.textContent = [
      "svg{color:#000}",
      "path{fill:currentColor}",
      "line,polyline,polygon,rect,circle,ellipse{stroke:currentColor; fill:none}",
      ".mjx-char,.mjx-n{fill:currentColor}"
    ].join("\n");
    clone.insertBefore(styleEl, clone.firstChild);
  }catch(e){ /* best-effort */ }

  // === Inline MathJax shared glyph defs ===
  // MathJax v2 often stores glyph definitions in a hidden SVG:
  //   <div id="MathJax_SVG_Hidden"> ... <defs> ... </defs> ...
  // Formula SVGs then use <use xlink:href="#MJX-...">. If we serialize just the formula SVG,
  // the <defs> are missing -> rasterizers render blank. We must copy those defs into the clone.
  try{
    let targetDefs = clone.querySelector("defs");
    if (!targetDefs){
      targetDefs = document.createElementNS(NS, "defs");
      // Put defs early so references resolve.
      clone.insertBefore(targetDefs, clone.firstChild);
    }

    const appendDefsChildren = (defsEl)=>{
      if (!defsEl) return;
      // Clone each child node and append (avoid SVG innerHTML pitfalls)
      defsEl.childNodes && Array.from(defsEl.childNodes).forEach(ch=>{
        if (ch.nodeType === 1 || ch.nodeType === 3){ // element or text
          targetDefs.appendChild(ch.cloneNode(true));
        }
      });
    };

    const hidden = document.getElementById("MathJax_SVG_Hidden");
    if (hidden){
      hidden.querySelectorAll("defs").forEach(appendDefsChildren);
    }
    const glyphs = document.getElementById("MathJax_SVG_glyphs");
    if (glyphs){
      glyphs.querySelectorAll("defs").forEach(appendDefsChildren);
    }
  }catch(e){ /* best-effort */ }

  // === Replace <use> with referenced glyphs to maximize renderer compatibility ===
  try{
    const idMap = new Map();
    clone.querySelectorAll("defs [id]").forEach(el=>{
      const id = el.getAttribute("id");
      if (id) idMap.set(id, el);
    });

    const uses = Array.from(clone.querySelectorAll("use"));
    for (const u of uses){
      const href = u.getAttribute("href") || u.getAttribute("xlink:href") || "";
      const id = href.startsWith("#") ? href.slice(1) : href;
      const ref = idMap.get(id);
      if (!ref) continue;

      const repl = ref.cloneNode(true);
      repl.removeAttribute("id");

      // Visibility defaults (some renderers ignore CSS)
      try{
        if (repl.tagName && repl.tagName.toLowerCase() === "path" && !repl.getAttribute("fill")){
          repl.setAttribute("fill", "currentColor");
        }
      }catch(e){}

      // Apply the <use> translation and transform, if present.
      const ux = parseFloat(u.getAttribute("x") || "0") || 0;
      const uy = parseFloat(u.getAttribute("y") || "0") || 0;
      const uTr = u.getAttribute("transform") || "";

      let tr = "";
      if (ux !== 0 || uy !== 0) tr += `translate(${ux} ${uy})`;
      if (uTr) tr += (tr ? " " : "") + uTr;

      if (tr){
        const rTr = repl.getAttribute("transform");
        repl.setAttribute("transform", rTr ? (tr + " " + rTr) : tr);
      }

      u.parentNode && u.parentNode.replaceChild(repl, u);
    }
  }catch(e){ /* best-effort */ }

  // Final safety: ensure paths have a fill so they aren't invisible.
  try{
    clone.querySelectorAll("path").forEach(p=>{
      if (!p.getAttribute("fill")) p.setAttribute("fill", "#000");
    });
  }catch(e){}

  return new XMLSerializer().serializeToString(clone);
}

function svgStringToImageElement(svgString){
  const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = ()=> reject(new Error("svg decode failed"));
    img.src = url;
  });
}

async function rasterizeSVGToCanvas(svgString, w, h){
  try{
    const blob = new Blob([svgString], { type: "image/svg+xml" });

    // Best: let the browser render the SVG -> bitmap (handles MathJax SVG reliably)
    if (window.createImageBitmap){
      try{
        const bmp = await createImageBitmap(blob);
        const c = document.createElement("canvas");
        c.width = w; c.height = h;
        const cx = c.getContext("2d");
        cx.drawImage(bmp, 0, 0, w, h);
        if (bmp && bmp.close) bmp.close();
        return c;
      }catch(e){ /* fall through */ }
    }

    // Fallback: Image element from object URL
    const url = URL.createObjectURL(blob);
    try{
      const img = await new Promise((resolve, reject)=>{
        const im = new Image();
        im.onload = ()=> resolve(im);
        im.onerror = ()=> reject(new Error("img decode failed"));
        im.src = url;
      });
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const cx = c.getContext("2d");
      cx.drawImage(img, 0, 0, w, h);
      return c;
    } finally {
      URL.revokeObjectURL(url);
    }
  }catch(e){
    return null;
  }
}

/* =====================
   Export helper: rasterize a text-box DOM node (including MathJax SVG + surrounding text)
   via SVG <foreignObject>. This preserves mixed content (plain text + formulas).
   ===================== */
async function rasterizeTextBoxNodeViaForeignObject(liveNode, boxW, boxH){
  try{
    const w = Math.max(1, Math.round(boxW || liveNode.offsetWidth || 1));
    const h = Math.max(1, Math.round(boxH || liveNode.offsetHeight || 1));

    // Clone the text box and neutralize positioning for export
    const clone = liveNode.cloneNode(true);
    try{
      clone.style.position = "relative";
      clone.style.left = "0px";
      clone.style.top  = "0px";
      clone.style.transform = "none";
      clone.style.pointerEvents = "none";
      clone.style.margin = "0";
      clone.style.width = w + "px";
      clone.style.height = h + "px";
    }catch(e){}

    // Inline MathJax shared glyph defs into every formula SVG inside the clone
    try{
      const liveSvgs = Array.from(liveNode.querySelectorAll("svg"));
      const cloneSvgs = Array.from(clone.querySelectorAll("svg"));
      const parser = new DOMParser();

      for (let i=0; i<Math.min(liveSvgs.length, cloneSvgs.length); i++){
        const sLive = liveSvgs[i];
        const sClone = cloneSvgs[i];

        const r = sLive.getBoundingClientRect();
        const sw = Math.max(1, Math.round(r.width || sLive.clientWidth || 1));
        const sh = Math.max(1, Math.round(r.height || sLive.clientHeight || 1));

        const standalone = buildStandaloneMathJaxSVG(sLive, sw, sh);
        const doc = parser.parseFromString(standalone, "image/svg+xml");
        const newSvg = doc.documentElement;
        if (newSvg && newSvg.tagName && newSvg.tagName.toLowerCase() === "svg"){
          // Ensure the SVG does not overflow in the foreignObject
          try{
            newSvg.setAttribute("width", String(sw));
            newSvg.setAttribute("height", String(sh));
          }catch(e){}
          sClone.parentNode && sClone.parentNode.replaceChild(newSvg, sClone);
        }
      }
    }catch(e){ /* best-effort */ }

    const foSvg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
  <foreignObject x="0" y="0" width="100%" height="100%">
    <div xmlns="http://www.w3.org/1999/xhtml" style="width:${w}px;height:${h}px;overflow:visible;">
      ${clone.outerHTML}
    </div>
  </foreignObject>
</svg>`;

    // Browser rasterization tends to support foreignObject; canvg usually doesn't.
    const c = await rasterizeSVGToCanvas(foSvg, w, h);
    return c;
  }catch(e){
    return null;
  }
}



function svgToImageElement(svgEl, targetW, targetH){
  const clone = svgEl.cloneNode(true);
  clone.setAttribute("width", String(targetW));
  clone.setAttribute("height", String(targetH));
      // Ensure namespaces for reliable rasterization
      if (!clone.getAttribute("xmlns")) clone.setAttribute("xmlns","http://www.w3.org/2000/svg");
      if (!clone.getAttribute("xmlns:xlink")) clone.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");
  const s = new XMLSerializer().serializeToString(clone);
  const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(s);

  // Return a promise (callers can await). Do not use `await` here, otherwise the
  // whole script becomes a SyntaxError in browsers.
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = ()=> reject(new Error("svg decode failed"));
    img.src = url;
  });
}

function drawPlainText2D(ctx, a){
  const size = (a.size || 20);
  const style = a.style || "regular";
  let weight = "400";
  let fontStyle = "normal";
  if (style === "bold"){ weight="700"; fontStyle="normal"; }
  if (style === "italic"){ weight="400"; fontStyle="italic"; }

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.86)";
  ctx.font = `${fontStyle} ${weight} ${size}px "Libertinus Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
  ctx.textBaseline = "top";
  const lines = String(a.raw || "").split("\n");
  const lh = Math.round(size * 1.25);
  let yy = Math.round(a.y);
  const xx = Math.round(a.x);
  for (const line of lines){
    ctx.fillText(line, xx, yy);
    yy += lh;
  }
  ctx.restore();
}

function stripTeX(raw){
  // Best-effort: keep content but remove common TeX delimiters so fallback text is readable.
  let s = String(raw || "");
  s = s.replace(/\$\$([\s\S]*?)\$\$/g, "$1");
  s = s.replace(/\$([^$\n]+)\$/g, "$1");
  s = s.replace(/\\\(([\s\S]*?)\\\)/g, "$1");
  s = s.replace(/\\\[([\s\S]*?)\\\]/g, "$1");
  return s;
}

function canvasHasInk(canvas){
  try{
    const ctx = canvas.getContext("2d");
    if (!ctx) return false;
    const w = canvas.width, h = canvas.height;
    if (!w || !h) return false;
    // Sample pixels sparsely for speed
    const step = Math.max(2, Math.floor(Math.min(w,h) / 40));
    const img = ctx.getImageData(0, 0, w, h).data;
    for (let y=0; y<h; y+=step){
      for (let x=0; x<w; x+=step){
        const i = 4*(y*w + x);
        const a = img[i+3];
        if (a > 20){
          // not fully transparent
          return true;
        }
      }
    }
    return false;
  }catch(e){
    return true; // if we can't inspect, assume it has ink
  }
}


function floodFillOnGraphics(pg, x, y, fillHex, fillAlpha){
  const ix = Math.floor(clamp(x, 0, pg.width-1));
  const iy = Math.floor(clamp(y, 0, pg.height-1));

  pg.loadPixels();
  const pix = pg.pixels;
  const W = pg.width, H = pg.height;

  const idx0 = 4*(iy*W + ix);
  const a0=pix[idx0+3];
  if (a0 > 12) return false;

  const c = color(fillHex);
  const fr = Math.round(red(c));
  const fg = Math.round(green(c));
  const fb = Math.round(blue(c));
  const fa = fillAlpha;

  const stack = [[ix,iy]];
  const visited = new Uint8Array(W*H);

  let filled=0;
  const MAX = 650000;

  while(stack.length){
    const [cx,cy] = stack.pop();
    const p = cy*W + cx;
    if (visited[p]) continue;
    visited[p]=1;

    const off = 4*p;
    const a = pix[off+3];
    if (a > 12) continue;

    pix[off]=fr; pix[off+1]=fg; pix[off+2]=fb; pix[off+3]=fa;
    filled++;
    if (filled > MAX) break;

    if (cx>0) stack.push([cx-1,cy]);
    if (cx<W-1) stack.push([cx+1,cy]);
    if (cy>0) stack.push([cx,cy-1]);
    if (cy<H-1) stack.push([cx,cy+1]);
  }

  pg.updatePixels();
  return filled>0;
}

function renderActionsToGraphics(pg){
  // Draw all visible layers by replaying actions (not using cached viewport buffers)
  const fillQueue = [];
  for (let li=0; li<3; li++){
    if (!layers[li].visible) continue;
    const actions = layers[li].actions || [];
    for (const a of actions){
      if (!a) continue;
      if (a.type === "text") continue;
      if (a.type === "fill"){ fillQueue.push(a); continue; }

      if (a.type === "path"){
        const pts=a.points || [];
        for (let k=1;k<pts.length;k++){
          const p0=pts[k-1], p1=pts[k];
          const avgP=((p0.p??1)+(p1.p??1))/2;
          const mult=pressureMultiplier(avgP, "pen");
          const w=(a.style?.baseWeight||2)*mult;

          if (a.style?.eraser){
            pg.erase();
            pg.stroke(0); pg.strokeWeight(w);
            pg.strokeCap(ROUND); pg.strokeJoin(ROUND);
            pg.line(p0.x,p0.y,p1.x,p1.y);
            pg.noErase();
          } else {
            const col=color(a.style?.color || "#111"); col.setAlpha(a.style?.alpha??255);
            pg.stroke(col); pg.strokeWeight(w);
            pg.strokeCap(ROUND); pg.strokeJoin(ROUND);
            pg.noFill();
            pg.line(p0.x,p0.y,p1.x,p1.y);
          }
        }
        continue;
      }

      pg.push();
      drawShapeAction(a, pg);
      pg.pop();
    }
  }

  // Apply fills last (so they fill enclosed areas)
  for (const f of fillQueue){
    floodFillOnGraphics(pg, f.x, f.y, f.color, f.alpha);
  }
}


/* =====================
   Export helper: draw mixed text + MathJax SVG (no foreignObject, avoids taint)
   ===================== */
function splitMixedMath(raw){
  // Returns an array of tokens: {type:"text",s} or {type:"math",s}
  const s = String(raw || "");
  const re = /(\$\$[\s\S]+?\$\$|\$[^$\n]+\$)/g;
  let out = [];
  let last = 0;
  let m;
  while ((m = re.exec(s)) !== null){
    if (m.index > last) out.push({type:"text", s: s.slice(last, m.index)});
    out.push({type:"math", s: m[0]});
    last = m.index + m[0].length;
  }
  if (last < s.length) out.push({type:"text", s: s.slice(last)});
  return out;
}

function set2DFont(ctx, sizePx, style){
  const size = Math.max(6, Math.round(sizePx || 20));
  let weight = "400";
  let fontStyle = "normal";
  if (style === "bold"){ weight="700"; fontStyle="normal"; }
  if (style === "italic"){ weight="400"; fontStyle="italic"; }
  ctx.font = `${fontStyle} ${weight} ${size}px "Libertinus Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
  ctx.textBaseline = "top";
  ctx.fillStyle = "rgba(0,0,0,0.86)";
  return size;
}

async function drawMixedTextAndMathSVG(ctx, raw, liveNode, x0, y0, fontSize, fontStyle){
  const svgs = Array.from(liveNode.querySelectorAll("svg"));
  if (!svgs.length) return false;

  const tokens = splitMixedMath(raw);
  let svgIdx = 0;

  const size = set2DFont(ctx, fontSize, fontStyle);
  const lineH = Math.round(size * 1.25);

  let cx = x0;
  let cy = y0;

  for (const t of tokens){
    if (t.type === "text"){
      const parts = String(t.s).split(/\n/);
      for (let pi=0; pi<parts.length; pi++){
        const seg = parts[pi];
        if (seg){
          ctx.fillText(seg, cx, cy);
          cx += ctx.measureText(seg).width;
        }
        if (pi < parts.length-1){
          cx = x0;
          cy += lineH;
        }
      }
      continue;
    }

    // math token
    const sLive = svgs[svgIdx++];
    if (!sLive){
      const fallback = stripTeX(t.s);
      ctx.fillText(fallback, cx, cy);
      cx += ctx.measureText(fallback).width;
      continue;
    }

    const r = sLive.getBoundingClientRect();
    const sw = Math.max(1, Math.round(r.width));
    const sh = Math.max(1, Math.round(r.height));

    const standalone = buildStandaloneMathJaxSVG(sLive, sw, sh);
    const c = await rasterizeSVGToCanvas(standalone, sw, sh);

    const dy = Math.round(size * 0.06);
    ctx.drawImage(c, cx, cy + dy, sw, sh);
    cx += sw;
  }

  return true;
}
async function composeExportCanvas(bb, PAD){
  // Ensure DOM text overlay exists + MathJax rendered so SVG exists
  rebuildTextOverlay();
  await typesetTextOverlay();

  const W = Math.max(1, Math.ceil(bb.w + 2*PAD));
  const H = Math.max(1, Math.ceil(bb.h + 2*PAD));

  // Draw strokes/shapes into p5 graphics (cropped)
  const g = createGraphics(W, H);
  g.pixelDensity(1);
  g.background(255);
  g.push();
  g.translate(-bb.x + PAD, -bb.y + PAD);
  renderActionsToGraphics(g);
  g.pop();

  // Composite onto HTML canvas and draw text (including MathJax SVG)
  const off = document.createElement("canvas");
  off.width = W;
  off.height = H;
  const ctx = off.getContext("2d");
  ctx.drawImage(g.elt, 0, 0);
  g.remove();

  for (let li=0; li<3; li++){
    if (!layers[li].visible) continue;
    const actions = layers[li].actions || [];
    for (let i=0;i<actions.length;i++){
      const a = actions[i];
      if (!a || a.type !== "text") continue;

      // position inside export
      const x = Math.round(a.x - bb.x + PAD);
      const y = Math.round(a.y - bb.y + PAD);

      const node = textOverlay.querySelector(`.text-box[data-layer="${li}"][data-index="${i}"]`);
      if (node){
        const bw = Math.max(1, node.offsetWidth || (a.w||1));
        const bh = Math.max(1, node.offsetHeight || (a.h||1));

        // If this text box contains MathJax SVG, draw plain text + rasterized formula SVGs (no foreignObject)
        if (node.querySelector("svg")){
          try{
            const ok = await drawMixedTextAndMathSVG(ctx, a.raw, node, x, y, a.size || 20, a.style || "regular");
            if (ok) continue;
          }catch(e){ /* fall through */ }
        }

        // No MathJax SVG (or failed): draw as plain text
        drawPlainText2D(ctx, { ...a, raw: stripTeX(a.raw), x, y });
        continue;
      }

      // fallback when DOM node is missing
      drawPlainText2D(ctx, { ...a, raw: stripTeX(a.raw), x, y });
    }
  }

  return off;
}
async function exportPNGCurrentSlide(){
  try{
    saveToStorage(slideKey);

    const bb = await computeExportBounds();
    if (!bb){
      showToast("Nothing to export", 1400);
      return;
    }

    const PAD = 16;
    const off = await composeExportCanvas(bb, PAD);

    const blob = await new Promise((resolve, reject)=>{
      off.toBlob((b)=> b ? resolve(b) : reject(new Error("toBlob failed")), "image/png");
    });

    // Prefer clipboard (as requested), but fall back to a normal download if blocked
    if (navigator.clipboard && window.ClipboardItem){
      try{
        await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
        showToast("PNG copied to clipboard", 1600);
        return;
      }catch(e){
        // fall through to download
      }
    }

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "whiteboard.png";
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1000);
    showToast("PNG downloaded", 1600);
  }catch(e){
    showToast("PNG export failed", 2200);
  }
}


/* =====================
   PDF export to file (cropped to used bounds)
   ===================== */
async function exportPDFCurrentSlide(){
  try{
    saveToStorage(slideKey);

    const bb = await computeExportBounds();
    if (!bb){
      showToast("Nothing to export", 1400);
      return;
    }

    const PAD = 16;
    const off = await composeExportCanvas(bb, PAD);

    const jspdf = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : null;
    if (!jspdf){
      showToast("PDF export unavailable", 2200);
      return;
    }

    const W = off.width, H = off.height;

    const landscape = (W > H);
    const doc = new jspdf({ orientation: landscape ? "landscape" : "portrait", unit: "pt", format: "a4" });

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 28;

    const maxW = pageW - 2*margin;
    const maxH = pageH - 2*margin;

    const scale = Math.min(maxW / W, maxH / H);
    const imgW = W * scale;
    const imgH = H * scale;

    const x = (pageW - imgW) / 2;
    const y = (pageH - imgH) / 2;

    // Pass the canvas directly (avoids toDataURL SecurityError if anything taints the canvas)
    doc.addImage(off, "PNG", x, y, imgW, imgH);

    const pdfBytes = doc.output("arraybuffer");
    const blob = new Blob([pdfBytes], {type:"application/pdf"});

    // Save dialog
    if (window.showSaveFilePicker){
      const handle = await window.showSaveFilePicker({
        suggestedName: "whiteboard.pdf",
        types: [{ description: "PDF", accept: {"application/pdf":[".pdf"]} }]
      });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      showToast("PDF saved", 1600);
      return;
    }

    // Fallback download
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "whiteboard.pdf";
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1000);
    showToast("PDF downloaded", 1600);
  }catch(e){
    showToast("PDF export failed", 2200);
  }
}



/* =====================
   JSON save/load (full presentation)
   ===================== */
function collectAllWhiteboardStorage(){
  const deckKey = getDeckKey();
  const prefix = STORAGE_PREFIX + deckKey + ":";
  const out = {};
  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (!k) continue;
    if (k.startsWith(prefix)) out[k] = localStorage.getItem(k);
  }
  return { deckKey, prefix, items: out };
}

async function saveAllAnnotationsJSON(){
  try{
    // ensure current slide saved
    saveToStorage(slideKey);

    const { deckKey, prefix, items } = collectAllWhiteboardStorage();
    const payload = {
      schema: 1,
      createdAt: new Date().toISOString(),
      presentationURL: normalizedPresentationURL(),
      deckKey,
      storagePrefix: prefix,
      items
    };

    const json = JSON.stringify(payload, null, 2);
    const blob = new Blob([json], { type: "application/json" });

    // Best UX when available
    if (window.showSaveFilePicker){
      const handle = await window.showSaveFilePicker({
        suggestedName: "whiteboard-annotations.json",
        types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      showToast("Saved JSON", 1600);
      return;
    }

    // Fallback download
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "whiteboard-annotations.json";
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1000);
    showToast("Downloaded JSON", 1600);
  }catch(e){
    showToast("Save failed", 2000);
  }
}

async function openAllAnnotationsJSON(){
  try{
    let file = null;

    if (window.showOpenFilePicker){
      const [handle] = await window.showOpenFilePicker({
        multiple: false,
        types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
      });
      file = await handle.getFile();
    } else {
      file = await new Promise((resolve)=>{
        const inp = document.createElement("input");
        inp.type = "file";
        inp.accept = ".json,application/json";
        inp.style.display = "none";
        inp.addEventListener("change", ()=>{
          resolve(inp.files && inp.files[0] ? inp.files[0] : null);
          inp.remove();
        });
        document.body.appendChild(inp);
        inp.click();
      });
    }

    if (!file){
      showToast("No file selected", 1400);
      return;
    }

    const text = await file.text();
    const data = safeParseJSON(text, null);
    if (!data || data.schema !== 1 || typeof data.items !== "object"){
      showToast("Invalid JSON", 2000);
      return;
    }

    const currentDeckKey = getDeckKey();
    if (data.deckKey !== currentDeckKey){
      showToast("JSON not for this deck", 2400);
      return;
    }

    // Apply into localStorage
    const items = data.items || {};
    for (const k of Object.keys(items)){
      const v = items[k];
      if (typeof v === "string") localStorage.setItem(k, v);
    }

    // Reload current slide
    loadFromStorage(slideKey);
    rebuildAllBuffers();
    rebuildTextOverlay();
    showToast("Loaded JSON", 1600);
  }catch(e){
    showToast("Open failed", 2000);
  }
}
</script>
</body>
</html>
