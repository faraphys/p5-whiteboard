<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>p5 Whiteboard (transparent, layers, clipboard copy)</title>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

  <style>
    :root{
      --panel: rgba(255,255,255,0.92);
      --border: rgba(0,0,0,0.12);
      --text: rgba(0,0,0,0.85);
      --shadow: 0 6px 18px rgba(0,0,0,0.10);
      --radius: 12px;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html, body{
      margin:0; height:100%;
      background: transparent;
      font-family: var(--font);
      color: var(--text);
      overflow:hidden;
    }

    #canvas-wrap{ position:fixed; inset:0; z-index:1; background:transparent; }

    /* thin outline so students see the active writing area */
    #canvas-outline{
      position:fixed;
      inset:0;
      border:1px solid rgba(140,140,140,0.35);
      pointer-events:none;
      z-index:2;
    }

    /* vertical toolbar (top-right, expanding down) */
    #ui{
      position:fixed;
      top:10px; right:10px;
      z-index:10;

      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:7px;

      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:8px;

      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      user-select:none;

      width: 136px;                 /* just wide enough for layers dropdown */
      max-width: calc(100vw - 20px);
      box-sizing:border-box;
    }

    #ui.collapsed .advanced{ display:none !important; }

    /* draggable handle: 6-dot grip + collapse button */
    #dragHandle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border:1px solid var(--border);
      border-radius:10px;
      background:white;
      cursor:grab;
      touch-action:none;
    }
    #dragHandle:active{ cursor:grabbing; }

    .dots{
      display:grid;
      grid-template-columns: repeat(3, 4px);
      grid-auto-rows:4px;
      gap:3px;
      opacity:0.55;
    }
    .dots span{
      width:4px; height:4px;
      border-radius:50%;
      background: rgba(0,0,0,0.55);
      display:block;
    }

    #collapseBtn{
      width:28px; height:28px;
      display:inline-flex; align-items:center; justify-content:center;
      border:1px solid var(--border);
      border-radius:999px;
      background:white;
      cursor:pointer;
      font-size:14px;
      line-height:1;
      padding:0;
      flex: 0 0 auto;
    }

    .tool{
      border:1px solid var(--border);
      background:white;
      color:var(--text);
      border-radius:999px;
      padding:7px 10px;
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
      text-align:center;
      width:100%;
      box-sizing:border-box;
    }
    .tool.active{
      background:rgba(0,0,0,0.92);
      border-color:rgba(0,0,0,0.92);
      color:white;
    }

    select{
      border:1px solid var(--border);
      border-radius:999px;
      padding:7px 10px;
      background:white;
      font-size:12px;
      cursor:pointer;
      width:100%;
      box-sizing:border-box;
    }

    button.action{
      border:1px solid var(--border);
      background:white;
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
      transition: transform .05s ease, background .12s ease;
      width:100%;
      box-sizing:border-box;
    }
    button.action:hover{ background: rgba(0,0,0,0.04); }
    button.action:active{ transform: translateY(1px); }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:7px 10px;
      background:white;
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
      width:100%;
      box-sizing:border-box;
      justify-content:flex-start;
    }
    .pill input{ margin:0; }

    /* color dropdown */
    .color-select{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      background:white;
      cursor:pointer;
      width:100%;
      box-sizing:border-box;
    }
    .color-left{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .chip{
      width:16px; height:16px;
      border-radius:4px;
      border:1px solid rgba(0,0,0,0.18);
      box-sizing:border-box;
      background:#111;
      flex: 0 0 auto;
    }
    .caret{ opacity:.7; font-size:12px; flex:0 0 auto; }

    .palette{
      position:absolute;
      top:110%;
      right:0;
      padding:8px;
      background:white;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:var(--shadow);
      display:none;
      z-index:9999;
      transform-origin: top right;
      transform: translateX(-36px); /* let it expand a bit left of toolbar */
    }
    .palette.open{ display:block; }
    .palette-grid{
      display:grid;
      grid-template-columns: repeat(6, 18px);
      gap:8px;
    }
    .swatch{
      width:18px; height:18px;
      border-radius:4px;
      border:1px solid rgba(0,0,0,0.18);
      cursor:pointer;
      box-sizing:border-box;
    }
    .swatch.active{
      outline:2px solid rgba(0,0,0,0.75);
      outline-offset:1px;
    }

    /* layers dropdown */
    .layers-select{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      background:white;
      cursor:pointer;
      width:100%;
      box-sizing:border-box;
    }
    .layers-menu{
      position:absolute;
      top:110%;
      right:0;
      padding:6px;
      background:white;
      border:1px solid var(--border);
      border-radius:12px;
      box-shadow:var(--shadow);
      display:none;
      z-index:9999;

      min-width: 190px;
      transform-origin: top right;
      transform: translateX(-60px); /* expand left */
    }
    .layers-menu.open{ display:block; }
    .layer-item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
      user-select:none;
    }
    .layer-item:hover{ background: rgba(0,0,0,0.04); }
    .layer-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    .tick{
      width:16px;
      text-align:center;
      opacity:0.9;
      font-weight:700;
    }
    .layer-name{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .vis-dot{
      width:10px; height:10px;
      border-radius:50%;
      border:1px solid rgba(0,0,0,0.22);
      background: rgba(0,0,0,0.10);
      flex: 0 0 auto;
    }
    .layer-item.invisible .layer-name{ opacity:0.45; text-decoration: line-through; }
    .layer-item.invisible .vis-dot{ opacity:0.25; }

    /* copy button with mini checkbox inside */
    .copy-btn{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .copy-mini{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:11px;
      opacity:0.85;
      cursor:pointer;
      user-select:none;
    }
    .copy-mini input{
      margin:0;
      width:14px;
      height:14px;
    }

    /* tiny status line */
    #status{
      font-size:11px;
      opacity:.75;
      line-height:1.15;
      padding:2px 2px 0 2px;
      min-height: 14px;
    }

    #ui, #ui * { touch-action: none; }
  </style>
</head>

<body>
  <div id="ui" class="collapsed">
    <div id="dragHandle" title="Drag toolbar">
      <div class="dots" aria-hidden="true">
        <span></span><span></span><span></span>
        <span></span><span></span><span></span>
      </div>
      <button id="collapseBtn" title="Collapse/expand">▸</button>
    </div>

    <!-- In collapsed state, students still see these -->
    <button class="tool" id="toolPen">Pen</button>
    <button class="tool" id="toolEraser">Eraser</button>

    <select id="shapeTool" title="Shape tool">
      <option value="" disabled selected>Shape</option>
      <option value="line">Line</option>
      <option value="arrow">Arrow</option>
      <option value="circle">Circle</option>
      <option value="rect">Rect</option>
    </select>

    <div class="color-select" id="colorSelect" title="Color">
      <div class="color-left">
        <div class="chip" id="colorChip"></div>
        <div style="font-size:12px; opacity:.85;">Color</div>
      </div>
      <div class="caret">▾</div>
      <div class="palette" id="palette">
        <div class="palette-grid" id="paletteGrid"></div>
      </div>
    </div>

    <!-- Advanced controls (hidden when collapsed) -->
    <select class="advanced" id="bgMode" title="Background type">
      <option value="transparent" selected>Bg: transp.</option>
      <option value="dots">Bg: dots</option>
      <option value="grid">Bg: grid</option>
    </select>

    <button class="tool advanced" id="toolLaser">Laser</button>

    <select class="advanced" id="lineStyle" title="Line style">
      <option value="solid">Solid</option>
      <option value="dotted">Dotted</option>
      <option value="dash">Dash</option>
      <option value="dashdot">Dash-dot</option>
    </select>

    <select class="advanced" id="strokeWidth" title="Stroke width">
      <option value="1">w 1</option>
      <option value="2" selected>w 2</option>
      <option value="3">w 3</option>
      <option value="4">w 4</option>
      <option value="5">w 5</option>
      <option value="8">w 8</option>
      <option value="10">w 10</option>
      <option value="20">w 20</option>
      <option value="30">w 30</option>
    </select>

    <select class="advanced" id="alphaLevel" title="Line transparency (1 = opaque, 10 = very transparent)">
      <option value="1" selected>α 1</option>
      <option value="2">α 2</option>
      <option value="3">α 3</option>
      <option value="4">α 4</option>
      <option value="5">α 5</option>
      <option value="6">α 6</option>
      <option value="7">α 7</option>
      <option value="8">α 8</option>
      <option value="9">α 9</option>
      <option value="10">α 10</option>
    </select>

    <select class="advanced" id="smoothing" title="Smoothing (1 = none, 10 = strong)">
      <option value="1">s 1</option>
      <option value="2" selected>s 2</option>
      <option value="3">s 3</option>
      <option value="4">s 4</option>
      <option value="5">s 5</option>
      <option value="6">s 6</option>
      <option value="7">s 7</option>
      <option value="8">s 8</option>
      <option value="9">s 9</option>
      <option value="10">s 10</option>
    </select>

    <label class="pill advanced" title="Snap points to grid">
      <input id="snap" type="checkbox" />
      Snap
    </label>

    <div class="layers-select advanced" id="layersSelect" title="Layers: click to select, click again on same layer to toggle visibility">
      <div style="font-size:12px; opacity:.85;" id="layersLabel">Layers</div>
      <div class="caret">▾</div>
      <div class="layers-menu" id="layersMenu"></div>
    </div>

    <button class="action advanced copy-btn" id="copy" title="Copy PNG to clipboard">
      <span>Copy</span>
      <label class="copy-mini" title="Include grid/dots in copied image">
        <input id="copyBg" type="checkbox" />
        <span>grid</span>
      </label>
    </button>

    <div id="status" class="advanced"></div>

    <button class="action advanced" id="undo" title="Undo (active layer)">Undo</button>
    <button class="action advanced" id="clear" title="Clear (active layer, undoable)">Clear</button>
  </div>

  <div id="canvas-wrap"></div>
  <div id="canvas-outline"></div>

<script>
/* =========================
   Whiteboard + Layers
   ========================= */

const GRID_STEP = 20;
const LASER_RED = { r: 215, g: 38, b: 61 }; // clearer red (not pure #ff0000)

const COLORS = [
  "#111111", // black
  "#D7263D", // strong red
  "#009E73", // green
  "#0072B2", // blue
  "#FFFFFF", // white
  "#E69F00", // orange
  "#F0E442", // yellow
  "#56B4E9", // light blue
  "#CC79A7", // purple/pink
  "#00BFC4", // cyan
  "#D55E00", // vermillion
  "#8C564B"  // brown
];

const TOOL_DEFAULT_SNAP = {
  pen:false, eraser:false, laser:false,
  line:true, arrow:true, circle:true, rect:true
};

let tool = "pen";
let lineStyle = "solid";
let strokeWidth = 2;
let smoothing = 2;
let alphaLevel = 1;
let currentColor = COLORS[0];
let lastNonEraserWidth = strokeWidth;
let snapToGrid = false;

let bgMode = "transparent"; // on-screen background overlay mode
let copyIncludeBg = false;  // include bg overlay in clipboard image?

const LAYER_COUNT = 3;
let layers = [];
let activeLayer = 0;

let current = null;

/* Soft clear: clears active layer but can be restored with Undo.
   After CLEAR_UNDO_WINDOW further actions, the cleared snapshot is forgotten. */
const CLEAR_UNDO_WINDOW = 12;
let softClearStack = Array.from({length:LAYER_COUNT}, () => []); // per-layer stack

/* Laser pointer */
let laserTrail = [];
const LASER_FADE_MS = 450;

/* Storage keys */
const params = new URLSearchParams(location.search);
const PAGE_ID = params.get("page") || params.get("p") || (location.hash ? location.hash.slice(1) : "default");
const STORAGE_KEY = `p5_whiteboard_layers_v8::${location.origin}${location.pathname}::page=${PAGE_ID}`;
const UI_POS_KEY  = `p5_whiteboard_ui_pos_v8::${location.origin}${location.pathname}`;

let saveTimer = null;
function scheduleSave() {
  if (saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(saveToLocalStorage, 160);
}

function alphaFromLevel(level){
  const l = Math.max(1, Math.min(10, level));
  // 1 -> 255 (opaque), 10 -> ~25 (very transparent)
  return Math.round(255 - (l - 1) * (230 / 9));
}

/* UI refs */
let ui, dragHandle, collapseBtn;
let toolPenBtn, toolEraserBtn, toolLaserBtn, shapeToolSel;
let bgModeSel, lineStyleSel, strokeWidthSel, alphaSel, smoothingSel;
let snapEl, undoBtn, clearBtn;
let copyBtn, copyBgEl, statusEl;
let colorSelect, palette, paletteGrid, colorChip;
let layersSelect, layersMenu, layersLabel;

function setup() {
  const c = createCanvas(windowWidth, windowHeight);
  c.parent("canvas-wrap");
  pixelDensity(1);

  layers = [];
  for (let i = 0; i < LAYER_COUNT; i++) {
    const pg = createGraphics(windowWidth, windowHeight);
    pg.pixelDensity(1);
    pg.clear();
    layers.push({ pg, actions: [], visible: true });
  }

  initUI();
  loadFromLocalStorage();
  rebuildAllBuffers();

  const canvasEl = document.querySelector("canvas");
  if (canvasEl) canvasEl.style.touchAction = "none";

  setTool("pen");
}

function draw() {
  clear();
  drawBackgroundOverlay(this, bgMode);

  for (let i = 0; i < LAYER_COUNT; i++) {
    if (!layers[i].visible) continue;
    image(layers[i].pg, 0, 0);
  }

  if (current && current.type !== "laser") drawAction(current, this, true);

  updateLaserTrail();
  drawLaserTrail();
}

/* ---------- UI ---------- */
function initUI() {
  ui = document.getElementById("ui");
  dragHandle = document.getElementById("dragHandle");
  collapseBtn = document.getElementById("collapseBtn");

  toolPenBtn = document.getElementById("toolPen");
  toolEraserBtn = document.getElementById("toolEraser");
  toolLaserBtn = document.getElementById("toolLaser");
  shapeToolSel = document.getElementById("shapeTool");

  colorSelect = document.getElementById("colorSelect");
  palette = document.getElementById("palette");
  paletteGrid = document.getElementById("paletteGrid");
  colorChip = document.getElementById("colorChip");

  bgModeSel = document.getElementById("bgMode");
  lineStyleSel = document.getElementById("lineStyle");
  strokeWidthSel = document.getElementById("strokeWidth");
  alphaSel = document.getElementById("alphaLevel");
  smoothingSel = document.getElementById("smoothing");
  snapEl = document.getElementById("snap");

  layersSelect = document.getElementById("layersSelect");
  layersMenu = document.getElementById("layersMenu");
  layersLabel = document.getElementById("layersLabel");

  copyBtn = document.getElementById("copy");
  copyBgEl = document.getElementById("copyBg");
  statusEl = document.getElementById("status");

  undoBtn = document.getElementById("undo");
  clearBtn = document.getElementById("clear");

  // start collapsed (per your preference)
  setCollapsed(true);

  buildPalette();
  setColor(currentColor);

  rebuildLayersMenu();
  updateLayersLabel();

  collapseBtn.addEventListener("click", (ev) => {
    ev.stopPropagation();
    setCollapsed(!ui.classList.contains("collapsed"));
  });

  toolPenBtn.addEventListener("click", () => { shapeToolSel.selectedIndex = 0; setTool("pen"); });
  toolEraserBtn.addEventListener("click", () => { shapeToolSel.selectedIndex = 0; setTool("eraser"); });
  toolLaserBtn.addEventListener("click", () => { shapeToolSel.selectedIndex = 0; setTool("laser"); });

  // shape tool: input fires more consistently than change across embedded contexts
  shapeToolSel.addEventListener("input", () => setTool(shapeToolSel.value));
  shapeToolSel.addEventListener("change", () => setTool(shapeToolSel.value));

  bgModeSel.addEventListener("change", () => { bgMode = bgModeSel.value; scheduleSave(); });

  lineStyleSel.addEventListener("change", () => { lineStyle = lineStyleSel.value; scheduleSave(); });

  strokeWidthSel.value = String(strokeWidth);
  strokeWidthSel.addEventListener("change", () => {
    strokeWidth = parseInt(strokeWidthSel.value, 10);
    if (tool !== "eraser") lastNonEraserWidth = strokeWidth;
    scheduleSave();
  });

  alphaSel.value = String(alphaLevel);
  alphaSel.addEventListener("change", () => { alphaLevel = parseInt(alphaSel.value, 10); scheduleSave(); });

  smoothingSel.value = String(smoothing);
  smoothingSel.addEventListener("change", () => { smoothing = parseInt(smoothingSel.value, 10); scheduleSave(); });

  snapEl.addEventListener("change", () => { snapToGrid = snapEl.checked; scheduleSave(); });

  copyBgEl.checked = copyIncludeBg;
  copyBgEl.addEventListener("change", () => { copyIncludeBg = copyBgEl.checked; scheduleSave(); });

  // don't trigger Copy when tapping the mini checkbox
  copyBgEl.addEventListener("pointerdown", (ev) => ev.stopPropagation());
  copyBgEl.addEventListener("click", (ev) => ev.stopPropagation());

  copyBtn.addEventListener("click", () => copyToClipboard());

  undoBtn.addEventListener("click", () => undoActiveLayer());
  clearBtn.addEventListener("click", () => softClearActiveLayer());

  // close popups when clicking elsewhere (capture helps inside iframes)
  document.addEventListener("pointerdown", (ev) => {
    const inColor = colorSelect.contains(ev.target);
    const inLayers = layersSelect.contains(ev.target);
    if (!inColor) palette.classList.remove("open");
    if (!inLayers) layersMenu.classList.remove("open");
  }, { capture: true });

  colorSelect.addEventListener("pointerdown", (ev) => {
    ev.stopPropagation();
    layersMenu.classList.remove("open");
    palette.classList.toggle("open");
  });

  layersSelect.addEventListener("pointerdown", (ev) => {
    ev.stopPropagation();
    palette.classList.remove("open");
    layersMenu.classList.toggle("open");
  });

  initDrag();
}

function setCollapsed(collapsed) {
  ui.classList.toggle("collapsed", collapsed);
  collapseBtn.textContent = collapsed ? "▸" : "▾";
}

/* ---------- Status ---------- */
let statusTimer = null;
function setStatus(msg){
  if (!statusEl) return;
  statusEl.textContent = msg || "";
  if (statusTimer) clearTimeout(statusTimer);
  if (msg) statusTimer = setTimeout(() => { statusEl.textContent = ""; }, 2600);
}

/* ---------- Palette ---------- */
function buildPalette() {
  paletteGrid.innerHTML = "";
  COLORS.forEach(hex => {
    const d = document.createElement("div");
    d.className = "swatch";
    d.style.background = hex;
    d.title = hex;
    d.addEventListener("pointerdown", (ev) => {
      ev.stopPropagation();
      setColor(hex);
      palette.classList.remove("open");
      scheduleSave();
    });
    paletteGrid.appendChild(d);
  });
}

function setColor(hex) {
  currentColor = hex;
  colorChip.style.background = hex;

  const sw = paletteGrid.querySelectorAll(".swatch");
  sw.forEach(el => {
    const bg = rgbToHex(getComputedStyle(el).backgroundColor);
    el.classList.toggle("active", bg === hex.toUpperCase());
  });
}

function rgbToHex(rgb) {
  const m = rgb.match(/\d+/g);
  if (!m || m.length < 3) return "#000000";
  const to2 = (n) => Number(n).toString(16).padStart(2, "0").toUpperCase();
  return `#${to2(m[0])}${to2(m[1])}${to2(m[2])}`;
}

/* ---------- Layers menu ---------- */
function updateLayersLabel(){
  const vis = layers[activeLayer]?.visible ? "on" : "off";
  layersLabel.textContent = `Layers (${activeLayer + 1}:${vis})`;
}

function rebuildLayersMenu() {
  layersMenu.innerHTML = "";
  for (let i = 0; i < LAYER_COUNT; i++) {
    const item = document.createElement("div");
    item.className = "layer-item" + (layers[i].visible ? "" : " invisible");

    const left = document.createElement("div");
    left.className = "layer-left";

    const tick = document.createElement("div");
    tick.className = "tick";
    tick.textContent = (i === activeLayer) ? "✓" : "";

    const visDot = document.createElement("div");
    visDot.className = "vis-dot";
    visDot.style.background = layers[i].visible ? "rgba(0,0,0,0.12)" : "rgba(0,0,0,0.03)";

    const name = document.createElement("div");
    name.className = "layer-name";
    name.textContent = `Layer ${i + 1}`;

    left.appendChild(tick);
    left.appendChild(visDot);
    left.appendChild(name);

    const right = document.createElement("div");
    right.style.fontSize = "12px";
    right.style.opacity = "0.65";
    right.textContent = layers[i].visible ? "on" : "off";

    item.appendChild(left);
    item.appendChild(right);

    item.addEventListener("pointerdown", (ev) => {
      ev.stopPropagation();

      if (activeLayer !== i) {
        activeLayer = i;                 // first click: select only
      } else {
        layers[i].visible = !layers[i].visible; // second click on same layer: toggle visibility
      }

      updateLayersLabel();
      rebuildLayersMenu();
      layersMenu.classList.remove("open");
      scheduleSave();
    });

    layersMenu.appendChild(item);
  }
}

/* ---------- Toolbar drag ---------- */
function initDrag() {
  try {
    const raw = localStorage.getItem(UI_POS_KEY);
    if (raw) {
      const p = JSON.parse(raw);
      if (p && typeof p.left === "number" && typeof p.top === "number") {
        ui.style.left = `${p.left}px`;
        ui.style.top  = `${p.top}px`;
        ui.style.right = "auto";
      }
    }
  } catch {}

  let dragging = false;
  let startX = 0, startY = 0;
  let startLeft = 0, startTop = 0;

  dragHandle.addEventListener("pointerdown", (ev) => {
    if (ev.target === collapseBtn) return;
    dragging = true;
    dragHandle.setPointerCapture(ev.pointerId);
    startX = ev.clientX;
    startY = ev.clientY;

    const rect = ui.getBoundingClientRect();
    startLeft = rect.left;
    startTop = rect.top;

    ui.style.left = `${startLeft}px`;
    ui.style.top = `${startTop}px`;
    ui.style.right = "auto";
  });

  dragHandle.addEventListener("pointermove", (ev) => {
    if (!dragging) return;

    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;

    let newLeft = startLeft + dx;
    let newTop  = startTop + dy;

    const rect = ui.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    newLeft = Math.max(8, Math.min(window.innerWidth - w - 8, newLeft));
    newTop  = Math.max(8, Math.min(window.innerHeight - h - 8, newTop));

    ui.style.left = `${newLeft}px`;
    ui.style.top  = `${newTop}px`;
  });

  dragHandle.addEventListener("pointerup", () => {
    if (!dragging) return;
    dragging = false;
    const rect = ui.getBoundingClientRect();
    try { localStorage.setItem(UI_POS_KEY, JSON.stringify({ left: rect.left, top: rect.top })); } catch {}
  });
}

/* ---------- Tool switching ---------- */
function setTool(t) {
  if (!t) return;
  current = null;
  tool = t;

  toolPenBtn.classList.toggle("active", tool === "pen");
  toolEraserBtn.classList.toggle("active", tool === "eraser");
  toolLaserBtn.classList.toggle("active", tool === "laser");

  snapToGrid = !!TOOL_DEFAULT_SNAP[tool];
  snapEl.checked = snapToGrid;

  // eraser: default width 10; return to previous width when leaving
  if (tool === "eraser") {
    lastNonEraserWidth = lastNonEraserWidth ?? strokeWidth;
    strokeWidth = 10;
    strokeWidthSel.value = "10";
  } else {
    strokeWidth = lastNonEraserWidth ?? 2;
    strokeWidthSel.value = String(strokeWidth);
  }

  if (tool === "line" || tool === "arrow" || tool === "circle" || tool === "rect") {
    const idx = Array.from(shapeToolSel.options).findIndex(o => o.value === tool);
    if (idx >= 0) shapeToolSel.selectedIndex = idx;
  }
}

/* ---------- Background overlay ---------- */
function drawBackgroundOverlay(target, mode) {
  if (mode === "transparent") return;

  if (mode === "grid") {
    target.push();
    target.stroke(0, 40);
    target.strokeWeight(1);
    for (let x = 0; x < width; x += GRID_STEP) target.line(x, 0, x, height);
    for (let y = 0; y < height; y += GRID_STEP) target.line(0, y, width, y);
    target.pop();
    return;
  }

  // dots
  target.push();
  target.noStroke();
  target.fill(0, 55);
  const r = 1.6;
  for (let x = 0; x < width; x += GRID_STEP) {
    for (let y = 0; y < height; y += GRID_STEP) {
      target.circle(x, y, 2*r);
    }
  }
  target.pop();
}

/* ---------- Snap ---------- */
function snapPoint(x, y) {
  if (!snapToGrid) return { x, y };
  return { x: Math.round(x / GRID_STEP) * GRID_STEP, y: Math.round(y / GRID_STEP) * GRID_STEP };
}

/* ---------- Pointer over UI ---------- */
function isPointerOverUI() {
  const r = ui.getBoundingClientRect();
  const x = mouseX, y = mouseY;
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

/* ---------- Input (mouse + pen/touch) ---------- */
function mousePressed() { if (isPointerOverUI()) return; startAction(mouseX, mouseY); }
function mouseDragged() { if (!current) return; extendAction(mouseX, mouseY); }
function mouseReleased() { finishAction(); }

function touchStarted() { if (isPointerOverUI()) return true; startAction(mouseX, mouseY); return false; }
function touchMoved() { if (!current) return true; extendAction(mouseX, mouseY); return false; }
function touchEnded() { if (isPointerOverUI()) return true; finishAction(); return false; }

/* ---------- Soft clear ---------- */
function bumpSoftClearCountdowns() {
  const S = softClearStack[activeLayer];
  if (!S.length) return;
  for (const entry of S) entry.countdown--;
  while (S.length && S[0].countdown <= 0) S.shift();
}

function softClearActiveLayer() {
  const L = layers[activeLayer];
  if (L.actions.length === 0) return;

  softClearStack[activeLayer].push({
    prevActions: L.actions.slice(),
    countdown: CLEAR_UNDO_WINDOW
  });

  L.actions = [];
  L.pg.clear();

  bumpSoftClearCountdowns();
  scheduleSave();
}

function undoActiveLayer() {
  const L = layers[activeLayer];

  // normal undo
  if (L.actions.length > 0) {
    L.actions.pop();
    rebuildLayerBuffer(activeLayer);
    scheduleSave();
    return;
  }

  // if empty, undo might restore last soft clear
  const stack = softClearStack[activeLayer];
  if (stack.length > 0) {
    const entry = stack.pop();
    L.actions = entry.prevActions.slice();
    rebuildLayerBuffer(activeLayer);
    scheduleSave();
  }
}

/* ---------- Clipboard copy (PNG) ---------- */
async function copyToClipboard(){
  try{
    if (!navigator.clipboard || typeof ClipboardItem === "undefined") {
      setStatus("Clipboard not available here.");
      return;
    }

    // Compose on an offscreen graphics. IMPORTANT: opaque background for OneNote.
    const g = createGraphics(width, height);
    g.pixelDensity(1);
    g.background(255); // OneNote: avoid transparent PNG -> black rectangle

    const modeForCopy = copyIncludeBg ? bgMode : "transparent";
    drawBackgroundOverlay(g, modeForCopy);

    for (let i = 0; i < LAYER_COUNT; i++){
      if (!layers[i].visible) continue;
      g.image(layers[i].pg, 0, 0);
    }

    const blob = await canvasToPngBlob(g.canvas);
    await navigator.clipboard.write([ new ClipboardItem({ "image/png": blob }) ]);

    setStatus("Copied. Paste into OneNote.");
    g.remove();
  } catch (e){
    setStatus("Copy blocked (iframe). Use screenshot.");
  }
}

function canvasToPngBlob(canvasEl){
  return new Promise((resolve, reject) => {
    try{
      canvasEl.toBlob((blob) => {
        if (!blob) reject(new Error("toBlob failed"));
        else resolve(blob);
      }, "image/png");
    } catch (e){
      reject(e);
    }
  });
}

/* ---------- Actions model ---------- */
function makeStyle() {
  const w = strokeWidth;
  const a = alphaFromLevel(alphaLevel);
  if (tool === "eraser") return { weight:w, color:null, alpha:255, eraser:true, lineStyle, smoothing };
  return { weight:w, color:currentColor, alpha:a, eraser:false, lineStyle, smoothing };
}

function closePopups(){
  palette.classList.remove("open");
  layersMenu.classList.remove("open");
}

function startAction(x, y) {
  closePopups();
  const p0 = snapPoint(x, y);

  if (tool === "laser") {
    laserTrail.push({ x:p0.x, y:p0.y, t: millis() });
    current = { type:"laser" };
    return;
  }

  const style = makeStyle();
  const layerIndex = activeLayer;

  if (tool === "pen" || tool === "eraser") current = { type:"path", style, points:[p0], layer: layerIndex };
  else if (tool === "line") current = { type:"line", style, a:p0, b:p0, layer: layerIndex };
  else if (tool === "arrow") current = { type:"arrow", style, a:p0, b:p0, layer: layerIndex };
  else if (tool === "circle") current = { type:"circle", style, c:p0, r:0, layer: layerIndex };
  else if (tool === "rect") current = { type:"rect", style, a:p0, b:p0, layer: layerIndex };
}

function extendAction(x, y) {
  if (!current) return;
  const p = snapPoint(x, y);

  if (current.type === "laser") {
    laserTrail.push({ x:p.x, y:p.y, t: millis() });
    return;
  }

  const L = layers[current.layer];

  if (current.type === "path") {
    const pts = current.points;
    const last = pts[pts.length - 1];
    if (dist(last.x, last.y, p.x, p.y) < 0.8) return;

    pts.push(p);
    if (pts.length >= 2) {
      const a0 = pts[pts.length - 2];
      const b0 = pts[pts.length - 1];

      // simple exponential smoothing toward new point
      const sm = current.style.smoothing || 1;
      const a = (sm <= 1) ? 1 : (2 / (sm + 1));
      const bx = a0.x + a * (b0.x - a0.x);
      const by = a0.y + a * (b0.y - a0.y);
      pts[pts.length - 1] = { x: bx, y: by };

      L.pg.push();
      beginInk(L.pg, current.style);
      drawStyledLine(L.pg, a0.x, a0.y, bx, by, current.style);
      endInk(L.pg, current.style);
      L.pg.pop();
    }
  } else if (current.type === "line" || current.type === "arrow" || current.type === "rect") {
    current.b = p;
  } else if (current.type === "circle") {
    current.r = dist(current.c.x, current.c.y, p.x, p.y);
  }
}

function finishAction() {
  if (!current) return;

  if (current.type === "laser") { current = null; return; }

  const L = layers[current.layer];

  // single point tap
  if (current.type === "path" && current.points.length === 1) {
    const p = current.points[0];
    L.pg.push();
    if (current.style.eraser) {
      L.pg.erase(); L.pg.noStroke(); L.pg.circle(p.x, p.y, current.style.weight); L.pg.noErase();
    } else {
      L.pg.noStroke();
      const col = color(current.style.color); col.setAlpha(current.style.alpha ?? 255);
      L.pg.fill(col);
      L.pg.circle(p.x, p.y, current.style.weight);
    }
    L.pg.pop();
  } else if (current.type !== "path") {
    L.pg.push();
    drawAction(current, L.pg, false);
    L.pg.pop();
  }

  L.actions.push(current);
  current = null;

  bumpSoftClearCountdowns();
  scheduleSave();
}

/* ---------- Drawing primitives ---------- */
function beginInk(target, style) {
  if (style.eraser) {
    target.erase();
    target.stroke(0);
    target.strokeWeight(style.weight);
    target.strokeCap(ROUND);
    target.noFill();
  } else {
    target.noErase();
    const col = color(style.color);
    col.setAlpha(style.alpha ?? 255);
    target.stroke(col);
    target.strokeWeight(style.weight);
    target.strokeCap(ROUND);
    target.noFill();
  }
}
function endInk(target, style) { if (style.eraser) target.noErase(); }

function drawAction(a, target, isPreview) {
  target.push();
  beginInk(target, a.style);

  // preview slightly more transparent so it doesn't look "final"
  if (isPreview && !a.style.eraser) {
    const col = color(a.style.color);
    col.setAlpha(Math.min(200, (a.style.alpha ?? 255)));
    target.stroke(col);
  }

  if (a.type === "path") {
    const pts = a.points;
    for (let i = 1; i < pts.length; i++) {
      drawStyledLine(target, pts[i-1].x, pts[i-1].y, pts[i].x, pts[i].y, a.style);
    }
    endInk(target, a.style);
    target.pop();
    return;
  }

  if (a.type === "line") drawStyledLine(target, a.a.x, a.a.y, a.b.x, a.b.y, a.style);
  else if (a.type === "arrow") drawStyledArrow(target, a.a.x, a.a.y, a.b.x, a.b.y, a.style);
  else if (a.type === "circle") {
    target.noErase();
    const col = color(a.style.eraser ? "#000000" : a.style.color);
    col.setAlpha(a.style.eraser ? 255 : (a.style.alpha ?? 255));
    target.stroke(col);
    target.noFill();
    target.circle(a.c.x, a.c.y, 2 * a.r);
  } else if (a.type === "rect") {
    const x = Math.min(a.a.x, a.b.x);
    const y = Math.min(a.a.y, a.b.y);
    const w = Math.abs(a.b.x - a.a.x);
    const h = Math.abs(a.b.y - a.a.y);
    target.noErase();
    const col = color(a.style.eraser ? "#000000" : a.style.color);
    col.setAlpha(a.style.eraser ? 255 : (a.style.alpha ?? 255));
    target.stroke(col);
    target.noFill();
    target.rect(x, y, w, h);
  }

  endInk(target, a.style);
  target.pop();
}

/* Line styles */
function drawStyledLine(target, x1, y1, x2, y2, style) {
  const mode = style.lineStyle || "solid";
  if (mode === "solid") { target.line(x1, y1, x2, y2); return; }

  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.hypot(dx, dy);
  if (len < 0.001) return;
  const ux = dx / len, uy = dy / len;

  const w = Math.max(1, style.weight || 1);
  const dotGap = 6 + 0.6 * w;
  const dashLen = 10 + 1.2 * w;
  const gapLen  = 6 + 0.8 * w;

  let t = 0;
  const drawDash = (a, b) => target.line(x1 + ux*a, y1 + uy*a, x1 + ux*b, y1 + uy*b);
  const drawDot  = (at) => { target.push(); target.strokeCap(ROUND); target.point(x1 + ux*at, y1 + uy*at); target.pop(); };

  if (mode === "dotted") {
    target.push(); target.strokeCap(ROUND); target.strokeWeight(w);
    while (t <= len) { drawDot(t); t += dotGap; }
    target.pop();
    return;
  }

  if (mode === "dash") {
    while (t < len) {
      const a = t;
      const b = Math.min(len, t + dashLen);
      drawDash(a, b);
      t += dashLen + gapLen;
    }
    return;
  }

  // dash-dot
  while (t < len) {
    let a = t;
    let b = Math.min(len, t + dashLen);
    drawDash(a, b);
    t += dashLen + gapLen;
    if (t >= len) break;
    drawDot(t);
    t += dotGap;
  }
}

function drawStyledArrow(target, x1, y1, x2, y2, style) {
  drawStyledLine(target, x1, y1, x2, y2, style);

  const ang = Math.atan2(y2 - y1, x2 - x1);
  const w = Math.max(1, style.weight || 1);
  const headLen = Math.max(10, 3.2 * w);
  const headAng = (28 * Math.PI) / 180;

  const x3 = x2 - headLen * Math.cos(ang - headAng);
  const y3 = y2 - headLen * Math.sin(ang - headAng);
  const x4 = x2 - headLen * Math.cos(ang + headAng);
  const y4 = y2 - headLen * Math.sin(ang + headAng);

  target.line(x2, y2, x3, y3);
  target.line(x2, y2, x4, y4);
}

/* ---------- Rebuild buffers ---------- */
function rebuildLayerBuffer(i) {
  const L = layers[i];
  L.pg.clear();
  for (const a of L.actions) {
    L.pg.push();
    drawAction(a, L.pg, false);
    L.pg.pop();
  }
}
function rebuildAllBuffers() { for (let i = 0; i < LAYER_COUNT; i++) rebuildLayerBuffer(i); }

/* ---------- Laser ---------- */
function updateLaserTrail() {
  const now = millis();
  laserTrail = laserTrail.filter(p => now - p.t < LASER_FADE_MS);
}
function drawLaserTrail() {
  if (laserTrail.length === 0) return;
  push(); noFill();
  for (let i = 1; i < laserTrail.length; i++) {
    const p = laserTrail[i-1], q = laserTrail[i];
    const age = millis() - q.t;
    const a = map(age, 0, LASER_FADE_MS, 180, 0, true);
    stroke(LASER_RED.r, LASER_RED.g, LASER_RED.b, a);
    strokeWeight(4); strokeCap(ROUND);
    line(p.x, p.y, q.x, q.y);
  }
  const last = laserTrail[laserTrail.length - 1];
  stroke(LASER_RED.r, LASER_RED.g, LASER_RED.b, 200);
  strokeWeight(10);
  point(last.x, last.y);
  pop();
}

/* ---------- Storage ---------- */
function saveToLocalStorage() {
  try {
    const payload = {
      version: 8,
      page: PAGE_ID,
      bgMode,
      copyIncludeBg,
      snapToGrid,
      lineStyle,
      strokeWidth,
      alphaLevel,
      smoothing,
      currentColor,
      activeLayer,
      layers: layers.map(L => ({ visible: L.visible, actions: L.actions }))
      // softClearStack intentionally not persisted (short-term)
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  } catch (e) {}
}

function loadFromLocalStorage() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (!data || data.version !== 8) return;

    if (typeof data.bgMode === "string") bgMode = data.bgMode;
    if (typeof data.copyIncludeBg === "boolean") copyIncludeBg = data.copyIncludeBg;

    if (typeof data.snapToGrid === "boolean") snapToGrid = data.snapToGrid;
    if (typeof data.lineStyle === "string") lineStyle = data.lineStyle;
    if (typeof data.strokeWidth === "number") strokeWidth = data.strokeWidth;
    if (typeof data.alphaLevel === "number") alphaLevel = data.alphaLevel;
    if (typeof data.smoothing === "number") smoothing = data.smoothing;
    if (typeof data.currentColor === "string") currentColor = data.currentColor;
    if (typeof data.activeLayer === "number") activeLayer = Math.max(0, Math.min(LAYER_COUNT - 1, data.activeLayer));

    if (Array.isArray(data.layers)) {
      for (let i = 0; i < LAYER_COUNT; i++) {
        if (!data.layers[i]) continue;
        if (typeof data.layers[i].visible === "boolean") layers[i].visible = data.layers[i].visible;
        if (Array.isArray(data.layers[i].actions)) layers[i].actions = data.layers[i].actions;
      }
    }

    // apply to UI
    bgModeSel.value = bgMode;
    copyBgEl.checked = copyIncludeBg;

    lineStyleSel.value = lineStyle;
    strokeWidthSel.value = String(strokeWidth);
    alphaSel.value = String(alphaLevel);
    smoothingSel.value = String(smoothing);
    snapEl.checked = snapToGrid;
    setColor(currentColor);

    rebuildLayersMenu();
    updateLayersLabel();
  } catch (e) {}
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  for (let i = 0; i < LAYER_COUNT; i++) {
    const old = layers[i].pg;
    const ng = createGraphics(windowWidth, windowHeight);
    ng.pixelDensity(1);
    ng.clear();
    ng.image(old, 0, 0);
    layers[i].pg = ng;
  }
}

/* Shortcut */
function keyPressed() {
  if (key === 'z' || key === 'Z') undoActiveLayer();
}
</script>
</body>
</html>
