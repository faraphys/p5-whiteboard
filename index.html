<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>p5 Whiteboard</title>

  <!-- p5 -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

  <!-- MathJax v2 (SVG output) with Gyre-Termes ("mathjax-termes" style) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      showProcessingMessages: false,
      messageStyle: "none",
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      SVG: {
        font: "Gyre-Termes",
        linebreaks: { automatic: true }
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_SVG"></script>

  <style>
    /* Libertinus Sans from your repo (woff2 in root) */
    @font-face{
      font-family:"Libertinus Sans";
      src:url("https://cdn.jsdelivr.net/gh/faraphys/fonts@main/LibertinusSans-Regular.woff2") format("woff2");
      font-style:normal; font-weight:400; font-display:swap;
    }
    @font-face{
      font-family:"Libertinus Sans";
      src:url("https://cdn.jsdelivr.net/gh/faraphys/fonts@main/LibertinusSans-Bold.woff2") format("woff2");
      font-style:normal; font-weight:700; font-display:swap;
    }
    @font-face{
      font-family:"Libertinus Sans";
      src:url("https://cdn.jsdelivr.net/gh/faraphys/fonts@main/LibertinusSans-Italic.woff2") format("woff2");
      font-style:italic; font-weight:400; font-display:swap;
    }

    :root{
      --panel: rgba(255,255,255,0.92);
      --border: rgba(0,0,0,0.12);
      --text: rgba(0,0,0,0.86);
      --shadow: 0 6px 18px rgba(0,0,0,0.10);
      --radius: 12px;
      --font: "Libertinus Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --outline: rgba(140,140,140,0.22);

      --grid-a: 9;
      --dots-a: 34;
      --dots-r: 2.4;
    }

    html, body{ margin:0; height:100%; background:transparent; font-family:var(--font); color:var(--text); overflow:hidden; }
    #canvas-wrap{ position:fixed; inset:0; z-index:1; background:transparent; }
    #canvas-outline{ position:fixed; inset:0; border:1px solid var(--outline); pointer-events:none; z-index:2; }

    #text-overlay{ position:fixed; inset:0; z-index:5; pointer-events:none; }
    .text-box{
      position:absolute;
      transform-origin: top left;
      pointer-events:none;
      white-space: pre-wrap;
      color:var(--text);
      font-family: var(--font);
    }

    #cursorHint{
      position:fixed; z-index:999999;
      padding:6px 8px;
      border-radius:10px;
      background:rgba(0,0,0,0.78);
      color:white;
      font-size:12px;
      pointer-events:none;
      opacity:0; transform: translateY(6px);
      transition: opacity 120ms ease, transform 120ms ease;
      white-space:nowrap;
    }
    #cursorHint.show{ opacity:1; transform: translateY(0); }

    /* toolbar */
    #ui{
      position:fixed; top:10px; right:10px; z-index:10;
      display:flex; flex-direction:column; align-items:stretch;
      gap:4px;
      background:var(--panel); border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:8px;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      user-select:none;
      width:146px;
      max-width: calc(100vw - 20px); box-sizing:border-box;
    }
    #ui.partial .advanced{ display:none !important; }
    #ui.full .core, #ui.full .advanced{ display:none !important; }

    .core, .advanced{ display:flex; flex-direction:column; gap:4px; }

    #dragHandle{
      display:flex; align-items:center; justify-content:space-between; gap:6px;
      padding:6px 8px; border:1px solid var(--border); border-radius:10px; background:rgba(255,255,255,0.88);
      cursor:grab; touch-action:none;
    }
    #dragHandle:active{ cursor:grabbing; }

    .dots{ display:grid; grid-template-columns: repeat(3, 4px); grid-auto-rows:4px; gap:3px; opacity:0.55; }
    .dots span{ width:4px; height:4px; border-radius:50%; background:rgba(0,0,0,0.55); display:block; }

    .handleBtns{ display:flex; gap:6px; align-items:center; }

    .miniBtn{
      width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center;
      border:1px solid var(--border); border-radius:999px; background:rgba(255,255,255,0.88); cursor:pointer;
      font-size:14px; line-height:1; padding:0; color:var(--text);
    }

    .shortcutWrap{ position:relative; }
    #shortcutCard{
      position:absolute; top:110%; right:0;
      background:rgba(255,255,255,0.96);
      border:1px solid var(--border);
      border-radius:12px; box-shadow:var(--shadow);
      padding:10px 10px;
      width:260px;
      display:none;
      z-index:99999;
      color:rgba(0,0,0,0.86);
      font-family: var(--font);
    }
    .shortcutWrap:hover #shortcutCard{ display:block; }
    #shortcutCard .title{ font-size:12px; font-weight:700; margin-bottom:6px; }
    #shortcutCard .row{ font-size:12px; display:flex; justify-content:space-between; gap:10px; opacity:0.88; }
    #shortcutCard .row code{
      background:rgba(0,0,0,0.06); padding:1px 6px; border-radius:7px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      color:inherit;
    }

    .tool, button.action{
      border:1px solid var(--border);
      background:rgba(255,255,255,0.88);
      color:var(--text);
      border-radius:999px; padding:7px 10px; font-size:12px; cursor:pointer;
      width:100%; box-sizing:border-box;
      display:flex; align-items:center; gap:8px; justify-content:flex-start;
      font-family: var(--font);
    }
    button.action{ border-radius:12px; padding:8px 10px; }
    .tool .ico, button.action .ico{ width:16px; text-align:center; opacity:0.90; }
    .tool.active{ background:rgba(0,0,0,0.92); border-color:rgba(0,0,0,0.92); color:white; }
    .ico.red{ color:#D7263D; opacity:1; }

    select{
      border:1px solid var(--border);
      border-radius:999px;
      padding:7px 10px;
      background:rgba(255,255,255,0.88);
      font-size:12px; cursor:pointer; width:100%; box-sizing:border-box;
      text-align:left; color:var(--text);
      font-family: var(--font);
    }
    select option{ text-align:left; }

    .pill{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border); border-radius:999px; padding:7px 10px;
      background:rgba(255,255,255,0.88); font-size:12px; cursor:pointer; white-space:nowrap;
      width:100%; box-sizing:border-box; justify-content:flex-start;
      color:var(--text);
      font-family: var(--font);
    }
    .pill input{ margin:0; }

    .color-select{
      position:relative; display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid var(--border); border-radius:999px; padding:6px 10px; background:rgba(255,255,255,0.88); cursor:pointer;
      width:100%; box-sizing:border-box;
      color:var(--text);
      font-family: var(--font);
    }
    .color-left{ display:flex; align-items:center; gap:8px; min-width:0; }
    .chip{ width:16px; height:16px; border-radius:4px; border:1px solid rgba(0,0,0,0.18); box-sizing:border-box; background:#111; }
    .caret{ opacity:.7; font-size:12px; flex:0 0 auto; }

    .palette{
      position:absolute; top:110%; right:0; padding:8px; background:rgba(255,255,255,0.98);
      border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow);
      display:none; z-index:9999; transform-origin: top right; transform: translateX(-36px);
    }
    .palette.open{ display:block; }
    .palette-grid{ display:grid; grid-template-columns: repeat(6, 18px); gap:8px; }
    .swatch{ width:18px; height:18px; border-radius:4px; border:1px solid rgba(0,0,0,0.18); cursor:pointer; box-sizing:border-box; }

    .layers-select{
      position:relative; display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid var(--border); border-radius:999px; padding:6px 10px; background:rgba(255,255,255,0.88); cursor:pointer;
      width:100%; box-sizing:border-box;
      color:var(--text);
      font-family: var(--font);
    }

    .layers-menu{
      position:absolute; top:110%; right:0; padding:6px; background:rgba(255,255,255,0.98);
      border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow);
      display:none; z-index:9999; min-width:190px; transform-origin: top right; transform: translateX(-80px);
      font-family: var(--font);
    }
    .layers-menu.open{ display:block; }

    .layer-item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px; border-radius:10px; cursor:pointer; font-size:12px; user-select:none;
    }
    .layer-item:hover{ background:rgba(0,0,0,0.04); }
    .layer-left{ display:flex; align-items:center; gap:10px; min-width:0; }
    .tick{ width:16px; text-align:center; opacity:0.9; font-weight:700; }
    .layer-name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .vis-dot{ width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,0.22); background:rgba(0,0,0,0.10); }
    .layer-item.invisible .layer-name{ opacity:0.45; text-decoration: line-through; }
    .layer-item.invisible .vis-dot{ opacity:0.25; }

    #textEditor{
      position:fixed; z-index:99999; display:none;
      min-width:280px; max-width:min(560px, calc(100vw - 24px));
      background:rgba(255,255,255,0.97);
      border:1px solid rgba(0,0,0,0.22);
      border-radius:12px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.14);
      padding:10px;
      color:rgba(0,0,0,0.86);
      font-family: var(--font);
    }
    #textEditorTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    #textEditorTitle{ font-size:12px; font-weight:700; opacity:0.85; }
    #textEditorTop select{ width:auto; padding:6px 10px; }
    #textEditor textarea{
      width:100%;
      border:1px solid rgba(0,0,0,0.16);
      border-radius:10px;
      padding:10px;
      resize:both;
      min-height:54px;
      font-family: var(--font);
      font-size: 14px;
      outline:none;
      box-sizing:border-box;
      background:white;
      color:rgba(0,0,0,0.86);
    }
    #textHint{ margin-top:8px; font-size:11px; opacity:0.65; }

    #ui, #ui * { touch-action: none; }
  </style>
</head>

<body>
  <div id="ui" class="partial">
    <div id="dragHandle" title="Drag toolbar">
      <div class="dots" aria-hidden="true">
        <span></span><span></span><span></span>
        <span></span><span></span><span></span>
      </div>

      <div class="handleBtns">
        <div class="shortcutWrap">
          <button id="btnShortcuts" class="miniBtn" title="Shortcuts">‚å®</button>
          <div id="shortcutCard">
            <div class="title">Shortcuts</div>
            <div class="row"><span><code>Esc</code></span><span>Pointer</span></div>
            <div class="row"><span><code>P</code></span><span>Pen</span></div>
            <div class="row"><span><code>E</code></span><span>Eraser</span></div>
            <div class="row"><span><code>H</code></span><span>Highlighter</span></div>
            <div class="row"><span><code>S</code></span><span>Cycle Shapes</span></div>
            <div class="row"><span><code>G</code></span><span>Cycle Grid</span></div>
            <div class="row"><span><code>N</code></span><span>Snap on/off</span></div>
            <div class="row"><span><code>F</code></span><span>Fill</span></div>
            <div class="row"><span><code>T</code></span><span>Text</span></div>
            <div class="row"><span><code>L</code></span><span>Lasso</span></div>
            <div class="row"><span><code>R</code></span><span>Laser</span></div>
            <div class="row"><span><code>Shift</code></span><span>Align line/arrow</span></div>
            <div class="row"><span><code>Ctrl+Z</code></span><span>Undo</span></div>
            <div class="row"><span><code>Del</code></span><span>Delete selection</span></div>
            <div class="row"><span><code>1..9</code></span><span>Width</span></div>
          </div>
        </div>

        <button id="btnCycle" class="miniBtn" title="Cycle toolbar"><span id="glyphCycle">‚ñæ</span></button>
      </div>
    </div>

    <!-- CORE -->
    <div class="core">
      <button class="tool" id="toolPen" title="Pen (P)"><span class="ico">‚úé</span><span>Pen</span></button>
      <button class="tool" id="toolEraser" title="Eraser (E)"><span class="ico">üßΩ</span><span>Eraser</span></button>
      <button class="tool" id="toolHighlighter" title="Highlighter (H)"><span class="ico">üñçÔ∏è</span><span>Highlighter</span></button>

      <!-- Shapes: preselect Arrow (no "Shapes" dropdown) -->
      <button class="tool" id="toolArrow" title="Arrow (S cycles shapes)"><span class="ico">‚Üí</span><span>Arrow</span></button>

      <div class="color-select" id="colorSelect" title="Color">
        <div class="color-left">
          <div class="chip" id="colorChip"></div>
          <div style="font-size:12px; opacity:.85;">üé®  Color</div>
        </div>
        <div class="caret">‚ñæ</div>
        <div class="palette" id="palette">
          <div class="palette-grid" id="paletteGrid"></div>
        </div>
      </div>
    </div>

    <!-- ADVANCED -->
    <div class="advanced">
      <select id="strokeWidth" title="Width"></select>
      <select id="smoothing" title="Smooth."></select>
      <select id="transp" title="Transp."></select>

      <button class="tool" id="toolFill" title="Fill (F)"><span class="ico">ü™£</span><span>Fill</span></button>
      <button class="tool" id="toolText" title="Text / LaTeX (T)"><span class="ico">T</span><span>Text / LaTeX</span></button>

      <button class="tool" id="toolLaser" title="Laser (R)"><span class="ico red">‚óé</span><span>Laser</span></button>
      <button class="tool" id="toolLasso" title="Lasso (L)"><span class="ico">‚ü≤</span><span>Lasso</span></button>

      <select id="bgMode" title="Background (G)">
        <option value="transparent" selected>‚ñ¶  Bg: transp.</option>
        <option value="dots">‚Ä¢  Bg: dots</option>
        <option value="grid">‚ßâ  Bg: grid</option>
      </select>

      <label class="pill" title="Snap (N)">
        <input id="snap" type="checkbox" />
        ‚åó  Snap
      </label>

      <div class="layers-select" id="layersSelect" title="Layers">
        <div style="font-size:12px; opacity:.85;" id="layersLabel">üß±  Layers</div>
        <div class="caret">‚ñæ</div>
        <div class="layers-menu" id="layersMenu"></div>
      </div>

      <button class="action" id="undo" title="Undo (Ctrl+Z)"><span class="ico">‚Ü∂</span><span>Undo</span></button>
      <button class="action" id="clear" title="Clear"><span class="ico">üóë</span><span>Clear</span></button>
    </div>
  </div>

  <div id="textEditor">
    <div id="textEditorTop">
      <div id="textEditorTitle">Enter text (LaTeX supported)</div>

      <select id="textStyleEditor" title="Font style">
        <option value="regular" selected>Regular</option>
        <option value="bold">Bold</option>
        <option value="italic">Italic</option>
      </select>

      <select id="textSizeEditor" title="Font size">
        <option value="10">10 pt</option>
        <option value="12">12 pt</option>
        <option value="14">14 pt</option>
        <option value="16">16 pt</option>
        <option value="20" selected>20 pt</option>
        <option value="24">24 pt</option>
        <option value="28">28 pt</option>
        <option value="36">36 pt</option>
        <option value="48">48 pt</option>
        <option value="72">72 pt</option>
      </select>
    </div>
    <textarea id="textInput" spellcheck="false"></textarea>
    <div id="textHint">e.g. <code>velocity $v_x$</code>. Ctrl+Enter = commit. Esc = cancel.</div>
  </div>

  <div id="canvas-wrap"></div>
  <div id="canvas-outline"></div>
  <div id="text-overlay"></div>
  <div id="cursorHint"></div>

<script>
/* =====================
   Config / state
   ===================== */
const GRID_STEP = 20;

// Laser fade
const LASER_FADE_MS = 2000;

// Hold alignment
const HOLD_ALIGN_MS = 500;
const STILL_EPS_PX = 7;
const STILL_TIME_MS = 120;

// Free-draw-to-line conversion
const FREE_LINE_MAX_DEVIATION = 7;
const FREE_LINE_MIN_LENGTH = 18;

// ellipse eccentricity 0.9
const ELLIPSE_E = 0.9;
const ELLIPSE_MINOR_RATIO = Math.sqrt(1 - ELLIPSE_E*ELLIPSE_E);

const COLORS = [
  "#111111", "#D7263D", "#009E73", "#0072B2", "#FFFFFF", "#FF8A00",
  "#E69F00", "#F0E442", "#56B4E9", "#CC79A7", "#00BFC4", "#D55E00",
  "#FFFF00", "#39FF14", "#FF00FF", "#00FFFF", "#B026FF", "#FF1744"
];

/* =====================
   Persistence (per slide)
   ===================== */
const STORAGE_PREFIX = "p5wb:v2:"; // bump if you change schema
let slideKey = "";
let lastSlideKey = "";

function safeParseJSON(s, fallback){
  try{ return JSON.parse(s); } catch(e){ return fallback; }
}
function getDeckKey(){
  // try to be stable across Slides.com embeds
  const u = new URL(window.location.href);
  const deck = u.searchParams.get("deck") || u.searchParams.get("deckId") || u.searchParams.get("id");
  const p = (u.pathname || "").replace(/\/+$/,"");
  return (deck || p || "deck").slice(0,200);
}
function getSlideKeyFromURL(){
  const u = new URL(window.location.href);
  // common indices/ids in query
  const sp = u.searchParams;
  const cand =
    sp.get("slide") || sp.get("s") ||
    (sp.get("h")!=null && sp.get("v")!=null ? `h${sp.get("h")}-v${sp.get("v")}` : "") ||
    sp.get("index") || sp.get("page") || sp.get("p");
  if (cand) return String(cand);

  // hash often changes on slide navigation
  const h = (u.hash || "").replace(/^#/,"").trim();
  if (h) return h;

  // last resort: full href (but keep short-ish)
  return (u.pathname + u.search + u.hash).slice(0,240) || "slide";
}
function storageKeyFor(slKey){
  return STORAGE_PREFIX + getDeckKey() + ":" + slKey;
}

function exportState(){
  return {
    v: 2,
    ts: Date.now(),
    bgMode,
    activeLayer,
    layers: layers.map(L => ({
      visible: !!L.visible,
      actions: L.actions || []
    }))
  };
}

function importState(state){
  if (!state || !state.layers || !Array.isArray(state.layers)) return false;

  bgMode = state.bgMode || "transparent";
  if (bgModeSel) bgModeSel.value = bgMode;

  activeLayer = clamp(parseInt(state.activeLayer ?? 0, 10) || 0, 0, 2);

  for (let i=0;i<3;i++){
    const src = state.layers[i] || {visible:true, actions:[]};
    layers[i].visible = (typeof src.visible === "boolean") ? src.visible : true;
    layers[i].actions = Array.isArray(src.actions) ? src.actions : [];
  }

  clearSelection();
  rebuildAllBuffers();
  rebuildTextOverlay();
  updateLayersLabel();
  rebuildLayersMenu();
  return true;
}

function saveToStorage(forKey){
  if (!layers || !layers.length) return;
  try{
    const k = storageKeyFor(forKey || slideKey);
    localStorage.setItem(k, JSON.stringify(exportState()));
  } catch(e){
    // ignore quota/blocked storage
  }
}

function loadFromStorage(forKey){
  const k = storageKeyFor(forKey || slideKey);
  const raw = localStorage.getItem(k);
  if (!raw) return false;
  const state = safeParseJSON(raw, null);
  return importState(state);
}

// Optional: accept slide id via postMessage (if you wire it up from Slides/reveal)
window.addEventListener("message", (ev)=>{
  const d = ev.data;
  if (!d || typeof d !== "object") return;

  // expected: {type:"whiteboard:setSlide", key:"h2-v0"} OR {type:"whiteboard:setSlide", h:2, v:0}
  if (d.type === "whiteboard:setSlide"){
    let k = d.key;
    if (!k && (d.h!=null || d.v!=null)) k = `h${d.h ?? 0}-v${d.v ?? 0}`;
    if (!k) return;

    k = String(k);
    if (k !== slideKey){
      // switch slide
      saveToStorage(slideKey);
      slideKey = k;
      lastSlideKey = k;
      // reset to empty before load (so stale drawings don't flash)
      for (let i=0;i<3;i++){ layers[i].actions=[]; layers[i].visible=true; layers[i].pg.clear(); }
      loadFromStorage(slideKey);
      rebuildAllBuffers();
      rebuildTextOverlay();
    }
  }

  // expected: {type:"whiteboard:save"} or {type:"whiteboard:clear"}
  if (d.type === "whiteboard:save") saveToStorage(slideKey);
  if (d.type === "whiteboard:clear"){
    for (let i=0;i<3;i++){ layers[i].actions=[]; layers[i].visible=true; layers[i].pg.clear(); }
    rebuildAllBuffers();
    rebuildTextOverlay();
    saveToStorage(slideKey);
  }
});

let tool = "pointer";
let strokeWidth = 2;
let smoothing = 2;
let transp = 1; // 1..10
let currentColor = COLORS[0];
let snapToGrid = false;
let bgMode = "transparent";

let lastNonEraserWidth = 2;
let current = null;
let laserTrail = [];

let pointerDown=false, activePointerId=null, activePointerType="mouse", lastPressure=1;
let isShiftDown = false;

const textOverlay = document.getElementById("text-overlay");
const cursorHint = document.getElementById("cursorHint");
let lastPointerClient = {x: 0, y: 0};

// memory to restore user pen/shapes values after highlighter/laser
let penState = { color: currentColor, width: strokeWidth, transp, smoothing };

// text tool
let defaultTextSize = 20;
let defaultTextStyle = "regular"; // regular|bold|italic
const textEditor = document.getElementById("textEditor");
const textInput  = document.getElementById("textInput");
const textSizeEditor = document.getElementById("textSizeEditor");
const textStyleEditor = document.getElementById("textStyleEditor");
let textDraft = null;

// Hold alignment timers
let holdAlignTimer = null;
let lastSignificantMoveAt = 0;
let lastMovePos = {x:0,y:0};

// Shapes cycling (S)
const SHAPES = ["line","arrow","circle","rect","ellipse"];
let shapeIndex = 1; // default to arrow

// Layers (3)
let layers = [];
let activeLayer = 0;
let undoStack = Array.from({length:3}, () => []);
const UNDO_LIMIT = 40;

/* =====================
   Lasso (move + delete only)
   ===================== */
let lasso = {
  points: [],
  selecting: false,
  selectedIdx: [],
  bbox: null,
  mode: "idle",       // idle | move
  moveStart: null
};

/* =====================
   Utilities
   ===================== */
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

function alphaFromTransp(t){
  const a = 255 - (t-1) * (230/9);
  return Math.round(clamp(a, 20, 255));
}
function snapPoint(x,y){
  if (!snapToGrid) return {x,y};
  return { x: Math.round(x/GRID_STEP)*GRID_STEP, y: Math.round(y/GRID_STEP)*GRID_STEP };
}
function pressureMultiplier(p, pointerType){
  const pr = Math.max(0, Math.min(1, (p ?? 1)));
  const isPen = (pointerType === "pen");
  if (!isPen && (pr === 0 || pr === 1)) return 1;
  return 0.45 + 1.10 * pr;
}
function showCursorHint(text, ms=700){
  cursorHint.textContent = text;
  cursorHint.style.left = (lastPointerClient.x + 12) + "px";
  cursorHint.style.top  = (lastPointerClient.y + 12) + "px";
  cursorHint.classList.add("show");
  setTimeout(()=> cursorHint.classList.remove("show"), ms);
}
function getCSSNum(varName){
  const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  return parseFloat(v || "0");
}

function pointInPoly(pt, poly){
  let inside=false;
  for (let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i].x, yi=poly[i].y;
    const xj=poly[j].x, yj=poly[j].y;
    const denom=(yj-yi)||1e-9;
    const intersect=((yi>pt.y)!==(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/denom + xi);
    if (intersect) inside=!inside;
  }
  return inside;
}

function pathBBox(a){
  const pts=a.points || [];
  if(!pts.length) return {x:0,y:0,w:0,h:0};
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of pts){
    minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
    maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
  }
  const pad = Math.max(6, (a.style?.baseWeight || 2) * 2);
  return { x:minX-pad, y:minY-pad, w:(maxX-minX)+2*pad, h:(maxY-minY)+2*pad };
}
function ellipseBBox(a){
  const cx=(a.a.x+a.b.x)/2, cy=(a.a.y+a.b.y)/2;
  const major = dist(a.a.x,a.a.y,a.b.x,a.b.y);
  const minor = major * ELLIPSE_MINOR_RATIO;
  const ang = Math.atan2(a.b.y-a.a.y, a.b.x-a.a.x);
  const A = major/2, B = minor/2;
  const c=Math.cos(ang), s=Math.sin(ang);
  const hw = Math.sqrt((A*c)**2 + (B*s)**2);
  const hh = Math.sqrt((A*s)**2 + (B*c)**2);
  return { x:cx-hw, y:cy-hh, w:2*hw, h:2*hh };
}
function actionBBox(a){
  if (a.type==="text"){
    const w = a.w || Math.max(40, Math.min(520, (a.size||20) * 0.62 * (a.raw?.length||1)));
    const h = a.h || Math.max(16, Math.min(240, (a.size||20) * 1.4));
    return { x:a.x, y:a.y, w, h };
  }
  if (a.type==="path") return pathBBox(a);
  if (a.type==="ellipse") return ellipseBBox(a);
  if (a.type==="line"||a.type==="arrow"||a.type==="rect"){
    const minX=Math.min(a.a.x,a.b.x), minY=Math.min(a.a.y,a.b.y);
    const maxX=Math.max(a.a.x,a.b.x), maxY=Math.max(a.a.y,a.b.y);
    return { x:minX, y:minY, w:maxX-minX, h:maxY-minY };
  }
  if (a.type==="circle"){
    return { x:a.c.x-a.r, y:a.c.y-a.r, w:2*a.r, h:2*a.r };
  }
  if (a.type==="fill"){
    return { x:a.x-8, y:a.y-8, w:16, h:16 };
  }
  return { x:0,y:0,w:0,h:0 };
}
function translateAction(a,dx,dy){
  if (a.type==="text"){ a.x+=dx; a.y+=dy; }
  else if (a.type==="path"){ for(const p of a.points){ p.x+=dx; p.y+=dy; } }
  else if (a.type==="ellipse"){ a.a.x+=dx; a.a.y+=dy; a.b.x+=dx; a.b.y+=dy; }
  else if (a.type==="line"||a.type==="arrow"||a.type==="rect"){ a.a.x+=dx; a.a.y+=dy; a.b.x+=dx; a.b.y+=dy; }
  else if (a.type==="circle"){ a.c.x+=dx; a.c.y+=dy; }
  else if (a.type==="fill"){ a.x+=dx; a.y+=dy; }
}
function clearSelection(){
  lasso.points=[];
  lasso.selecting=false;
  lasso.selectedIdx=[];
  lasso.bbox=null;
  lasso.mode="idle";
  lasso.moveStart=null;
}
function recomputeSelectionBBox(){
  const L=layers[activeLayer];
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const idx of lasso.selectedIdx){
    const bb=actionBBox(L.actions[idx]);
    minX=Math.min(minX,bb.x); minY=Math.min(minY,bb.y);
    maxX=Math.max(maxX,bb.x+bb.w); maxY=Math.max(maxY,bb.y+bb.h);
  }
  lasso.bbox={x:minX,y:minY,w:maxX-minX,h:maxY-minY};
}
function lassoSelect(){
  const poly = lasso.points.slice();
  lasso.points=[];
  if(poly.length<3){ clearSelection(); return; }

  const L=layers[activeLayer];
  const selected=[];
  for(let i=0;i<L.actions.length;i++){
    const a=L.actions[i];
    const bb=actionBBox(a);
    const corners=[
      {x:bb.x,y:bb.y},{x:bb.x+bb.w,y:bb.y},
      {x:bb.x+bb.w,y:bb.y+bb.h},{x:bb.x,y:bb.y+bb.h}
    ];
    const center={x:bb.x+bb.w/2,y:bb.y+bb.h/2};

    let hit = corners.some(p=>pointInPoly(p,poly)) || pointInPoly(center,poly);
    if(!hit && a.type==="path"){
      for(const p of (a.points||[])){
        if(pointInPoly({x:p.x,y:p.y}, poly)){ hit=true; break; }
      }
    }
    if(hit) selected.push(i);
  }

  lasso.selectedIdx=selected;
  if(!selected.length){ lasso.bbox=null; return; }
  recomputeSelectionBBox();
}
function pointInBBox(x,y,bb){
  if(!bb) return false;
  return (x>=bb.x && x<=bb.x+bb.w && y>=bb.y && y<=bb.y+bb.h);
}
function deleteSelection(){
  if(!lasso.selectedIdx.length) return;
  pushUndo(activeLayer);
  const L=layers[activeLayer];
  const idxs = lasso.selectedIdx.slice().sort((a,b)=>b-a);
  for(const idx of idxs) L.actions.splice(idx,1);
  // keep things simple: remove stored fills if structure changed
  L.actions = L.actions.filter(a => a.type !== "fill");

  clearSelection();
  rebuildLayerBuffer(activeLayer);
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   Undo
   ===================== */
function pushUndo(layerIndex){
  const L = layers[layerIndex];
  undoStack[layerIndex].push(JSON.stringify({ actions: L.actions, visible: L.visible }));
  if (undoStack[layerIndex].length > UNDO_LIMIT) undoStack[layerIndex].shift();
}
function undoActiveLayer(){
  const st = undoStack[activeLayer];
  if (!st.length) return;
  const snap = JSON.parse(st.pop());
  layers[activeLayer].actions = snap.actions || [];
  layers[activeLayer].visible = (typeof snap.visible==="boolean") ? snap.visible : true;
  rebuildLayerBuffer(activeLayer);
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   p5 setup/draw
   ===================== */
function setup(){
  const c = createCanvas(windowWidth, windowHeight);
  c.parent("canvas-wrap");
  pixelDensity(1);

  layers = [];
  for (let i=0;i<3;i++){
    const pg = createGraphics(windowWidth, windowHeight);
    pg.pixelDensity(1);
    pg.clear();
    layers.push({ pg, actions: [], visible: true });
  }

  // init persistence key
  slideKey = getSlideKeyFromURL();
  lastSlideKey = slideKey;

  initUI();

  // load saved drawing for this slide (if any)
  loadFromStorage(slideKey);

  rebuildAllBuffers();
  rebuildTextOverlay();

  // poll for slide changes (hash/query often changes in Slides/reveal embeds)
  setInterval(()=>{
    const k = getSlideKeyFromURL();
    if (k && k !== lastSlideKey){
      saveToStorage(lastSlideKey);
      lastSlideKey = k;
      slideKey = k;

      // reset quickly to avoid showing previous slide
      for (let i=0;i<3;i++){ layers[i].actions=[]; layers[i].visible=true; layers[i].pg.clear(); }

      loadFromStorage(slideKey);
      rebuildAllBuffers();
      rebuildTextOverlay();
    }
  }, 350);

  // save on background/unload
  document.addEventListener("visibilitychange", ()=>{
    if (document.hidden) saveToStorage(slideKey);
  });
  window.addEventListener("beforeunload", ()=> saveToStorage(slideKey));

  const canvasEl = document.querySelector("canvas");
  canvasEl.style.touchAction="none";
  canvasEl.addEventListener("pointerdown", onPointerDown, {passive:false});
  canvasEl.addEventListener("pointermove", onPointerMove, {passive:false});
  canvasEl.addEventListener("pointerup", onPointerUp, {passive:false});
  canvasEl.addEventListener("pointercancel", onPointerUp, {passive:false});

  document.addEventListener("pointerdown",(ev)=>{
    if (textEditor.style.display==="none") return;
    if (textEditor.contains(ev.target)) return;
    commitTextEdit();
  }, {capture:true});

  textInput.addEventListener("keydown",(ev)=>{
    if ((ev.ctrlKey||ev.metaKey) && ev.key==="Enter"){
      ev.preventDefault();
      commitTextEdit();
    } else if (ev.key==="Escape"){
      ev.preventDefault();
      cancelTextEdit();
      setTool("pointer");
    }
  });

  document.addEventListener("keydown", onKeyDown);
  document.addEventListener("keyup", (ev)=>{ if (ev.key==="Shift") isShiftDown=false; });

  setTool("pointer");
}

function draw(){
  clear();
  drawBackgroundOverlay(this, bgMode);

  for (let i=0;i<3;i++){
    if (!layers[i].visible) continue;
    image(layers[i].pg,0,0);
  }

  if (current && current.type !== "laser" && tool!=="lasso") drawCurrentPreview(current);

  drawLassoOverlay();
  updateLaserTrail();
  drawLaserTrail();
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  for (let i=0;i<3;i++){
    const old=layers[i].pg;
    const ng=createGraphics(windowWidth, windowHeight);
    ng.pixelDensity(1);
    ng.clear();
    ng.image(old,0,0);
    layers[i].pg = ng;
  }
  rebuildAllBuffers();
  rebuildTextOverlay();
}

/* =====================
   Background overlay
   ===================== */
function drawBackgroundOverlay(target, mode){
  if (mode==="transparent") return;

  const gridA = getCSSNum("--grid-a");
  const dotsA = getCSSNum("--dots-a");
  const dotsR = getCSSNum("--dots-r");

  if (mode==="grid"){
    target.push();
    target.stroke(0, gridA);
    target.strokeWeight(1);
    for (let x=0;x<width;x+=GRID_STEP) target.line(x,0,x,height);
    for (let y=0;y<height;y+=GRID_STEP) target.line(0,y,width,y);
    target.pop();
    return;
  }

  target.push();
  target.noStroke();
  target.fill(0, dotsA);
  for (let x=0;x<width;x+=GRID_STEP){
    for (let y=0;y<height;y+=GRID_STEP){
      target.circle(x,y,dotsR);
    }
  }
  target.pop();
}

/* =====================
   Actions: draw helpers
   ===================== */
function makeStyleForCurrent(pressure, pointerType){
  const mult = pressureMultiplier(pressure, pointerType);
  const w = strokeWidth * mult;
  const alpha = alphaFromTransp(transp);
  if (tool==="eraser") return { eraser:true, baseWeight:strokeWidth, weight:w, color:null, alpha:255, smoothing };
  return { eraser:false, baseWeight:strokeWidth, weight:w, color:currentColor, alpha, smoothing };
}

function drawArrowHead(target, x1,y1,x2,y2, style){
  const ang = Math.atan2(y2-y1, x2-x1);
  const w = Math.max(1, style.weight || 1);
  const headLen = Math.max(10, 3.2*w);
  const headAng = (28*Math.PI)/180;
  const x3 = x2 - headLen*Math.cos(ang - headAng);
  const y3 = y2 - headLen*Math.sin(ang - headAng);
  const x4 = x2 - headLen*Math.cos(ang + headAng);
  const y4 = y2 - headLen*Math.sin(ang + headAng);
  target.line(x2,y2,x3,y3);
  target.line(x2,y2,x4,y4);
}

function drawShapeAction(a, target){
  const st=a.style;
  if (st.eraser){
    target.erase(); target.stroke(0);
    target.strokeWeight(st.weight); target.strokeCap(ROUND); target.strokeJoin(ROUND); target.noFill();
  } else {
    const col=color(st.color); col.setAlpha(st.alpha??255);
    target.stroke(col); target.strokeWeight(st.weight); target.strokeCap(ROUND); target.strokeJoin(ROUND); target.noFill();
  }

  if (a.type==="line") target.line(a.a.x,a.a.y,a.b.x,a.b.y);
  else if (a.type==="arrow"){ target.line(a.a.x,a.a.y,a.b.x,a.b.y); drawArrowHead(target,a.a.x,a.a.y,a.b.x,a.b.y,st); }
  else if (a.type==="circle") target.circle(a.c.x,a.c.y,2*a.r);
  else if (a.type==="rect"){
    const x=Math.min(a.a.x,a.b.x), y=Math.min(a.a.y,a.b.y);
    const w=Math.abs(a.b.x-a.a.x), h=Math.abs(a.b.y-a.a.y);
    target.rect(x,y,w,h);
  }
  else if (a.type==="ellipse"){
    const cx=(a.a.x+a.b.x)/2, cy=(a.a.y+a.b.y)/2;
    const major = dist(a.a.x,a.a.y,a.b.x,a.b.y);
    const minor = major * ELLIPSE_MINOR_RATIO;
    const ang = Math.atan2(a.b.y-a.a.y, a.b.x-a.a.x);
    target.push();
    target.translate(cx,cy);
    target.rotate(ang);
    target.ellipse(0,0, major, minor);
    target.pop();
  }

  if (st.eraser) target.noErase();
}

function drawCurrentPreview(a){
  if (a.type==="path"){
    push();
    const pts=a.points;
    for (let k=1;k<pts.length;k++){
      const p0=pts[k-1], p1=pts[k];
      const avgP=((p0.p??1)+(p1.p??1))/2;
      const mult=pressureMultiplier(avgP, a.pointerType||"pen");
      const w=(a.style.baseWeight||2)*mult;

      if (a.style.eraser){
        erase();
        stroke(0); strokeWeight(w); strokeCap(ROUND); strokeJoin(ROUND);
        line(p0.x,p0.y,p1.x,p1.y);
        noErase();
      } else {
        const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
        stroke(col); strokeWeight(w); strokeCap(ROUND); strokeJoin(ROUND);
        line(p0.x,p0.y,p1.x,p1.y);
      }
    }
    pop();
    return;
  }

  if (["line","arrow","circle","rect","ellipse"].includes(a.type)){
    push();
    drawShapeAction(a, this);
    pop();
  }
}

/* =====================
   Fill tool
   ===================== */
function floodFillOnLayer(layerIndex, x, y, fillHex, fillAlpha){
  const L = layers[layerIndex];
  const pg = L.pg;

  const ix = Math.floor(clamp(x, 0, width-1));
  const iy = Math.floor(clamp(y, 0, height-1));

  pg.loadPixels();
  const pix = pg.pixels;
  const W = width, H = height;

  const idx0 = 4*(iy*W + ix);
  const a0=pix[idx0+3];
  if (a0 > 12) return false;

  const c = color(fillHex);
  const fr = Math.round(red(c));
  const fg = Math.round(green(c));
  const fb = Math.round(blue(c));
  const fa = fillAlpha;

  const stack = [[ix,iy]];
  const visited = new Uint8Array(W*H);

  let filled=0;
  const MAX = 650000;

  while(stack.length){
    const [cx,cy] = stack.pop();
    const p = cy*W + cx;
    if (visited[p]) continue;
    visited[p]=1;

    const off = 4*p;
    const a = pix[off+3];
    if (a > 12) continue;

    pix[off]=fr; pix[off+1]=fg; pix[off+2]=fb; pix[off+3]=fa;
    filled++;
    if (filled > MAX) break;

    if (cx>0) stack.push([cx-1,cy]);
    if (cx<W-1) stack.push([cx+1,cy]);
    if (cy>0) stack.push([cx,cy-1]);
    if (cy<H-1) stack.push([cx,cy+1]);
  }

  pg.updatePixels();
  return filled>0;
}

/* =====================
   Rebuild layer buffers
   ===================== */
function rebuildLayerBuffer(i){
  const L=layers[i];
  L.pg.clear();

  for (const a of L.actions){
    if (a.type==="text" || a.type==="fill") continue;

    if (a.type==="path"){
      const pts=a.points;
      for (let k=1;k<pts.length;k++){
        const p0=pts[k-1], p1=pts[k];
        const avgP=((p0.p??1)+(p1.p??1))/2;
        const mult=pressureMultiplier(avgP, "pen");
        const w=(a.style.baseWeight||2)*mult;

        if (a.style.eraser){
          L.pg.erase();
          L.pg.stroke(0); L.pg.strokeWeight(w);
          L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
          L.pg.line(p0.x,p0.y,p1.x,p1.y);
          L.pg.noErase();
        } else {
          const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
          L.pg.stroke(col); L.pg.strokeWeight(w);
          L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
          L.pg.line(p0.x,p0.y,p1.x,p1.y);
        }
      }
      continue;
    }

    L.pg.push();
    drawShapeAction(a, L.pg);
    L.pg.pop();
  }

  for (const a of L.actions){
    if (a.type!=="fill") continue;
    floodFillOnLayer(i, a.x, a.y, a.color, a.alpha);
  }
}
function rebuildAllBuffers(){ for (let i=0;i<3;i++) rebuildLayerBuffer(i); }

/* =====================
   Laser
   ===================== */
function updateLaserTrail(){
  const now=millis();
  laserTrail = laserTrail.filter(p=> now-p.t < LASER_FADE_MS);
}
function drawLaserTrail(){
  if(!laserTrail.length) return;

  const w = Math.max(1, strokeWidth);
  const c = color(currentColor);

  push(); noFill();
  for(let i=1;i<laserTrail.length;i++){
    const p=laserTrail[i-1], q=laserTrail[i];
    const age=millis()-q.t;
    const a=map(age,0,LASER_FADE_MS,200,0,true);
    stroke(red(c),green(c),blue(c),a);
    strokeWeight(w); strokeCap(ROUND);
    line(p.x,p.y,q.x,q.y);
  }
  const last=laserTrail[laserTrail.length-1];
  stroke(red(c),green(c),blue(c),210);
  strokeWeight(Math.max(8, w*2.2));
  point(last.x,last.y);
  pop();
}

/* =====================
   Lasso overlay
   ===================== */
function drawLassoOverlay(){
  if (tool==="lasso" && lasso.selecting && lasso.points.length){
    push(); noFill();
    stroke(0, 90);
    strokeWeight(2);
    beginShape(); for(const p of lasso.points) vertex(p.x,p.y); endShape();
    pop();
  }

  if (lasso.selectedIdx.length && lasso.bbox){
    const bb = lasso.bbox;
    push();
    noFill();
    stroke(0, 140);
    strokeWeight(2);
    drawingContext.setLineDash([6,6]);
    rect(bb.x, bb.y, bb.w, bb.h);
    drawingContext.setLineDash([]);
    pop();
  }
}

/* =====================
   Line/arrow alignment
   ===================== */
function maybeAlignLineLike(a){
  if (!a || !(a.type==="line" || a.type==="arrow")) return;
  const dx = a.b.x - a.a.x;
  const dy = a.b.y - a.a.y;
  if (Math.abs(dx) >= Math.abs(dy)) a.b.y = a.a.y;
  else a.b.x = a.a.x;
}
function clearHoldAlignTimer(){
  if (holdAlignTimer){ clearTimeout(holdAlignTimer); holdAlignTimer=null; }
}
function armHoldAlignTimer(){
  clearHoldAlignTimer();
  holdAlignTimer = setTimeout(()=>{
    if (!current) return;

    if (current.type==="line" || current.type==="arrow"){
      maybeAlignLineLike(current);
      return;
    }

    if (current.type==="path" && tool==="pen"){
      const lineObj = maybeConvertPathToAxisLine(current);
      if (lineObj){
        current = lineObj;
        maybeAlignLineLike(current);
      }
    }
  }, HOLD_ALIGN_MS);
}
function isStill(now, x, y){
  const moved = dist2(x,y,lastMovePos.x,lastMovePos.y) > STILL_EPS_PX*STILL_EPS_PX;
  if (moved){
    lastMovePos = {x,y};
    lastSignificantMoveAt = now;
    clearHoldAlignTimer();
    return false;
  }
  return (now - lastSignificantMoveAt) > STILL_TIME_MS;
}
function pointLineDist(px,py, ax,ay, bx,by){
  const vx=bx-ax, vy=by-ay;
  const wx=px-ax, wy=py-ay;
  const c1 = vx*wx + vy*wy;
  const c2 = vx*vx + vy*vy || 1e-9;
  const t = c1 / c2;
  const projx = ax + t*vx;
  const projy = ay + t*vy;
  return Math.hypot(px-projx, py-projy);
}
function maybeConvertPathToAxisLine(pathAction){
  const pts = pathAction.points || [];
  if (pts.length < 3) return null;
  const a0 = pts[0];
  const a1 = pts[pts.length-1];
  const len = Math.hypot(a1.x-a0.x, a1.y-a0.y);
  if (len < FREE_LINE_MIN_LENGTH) return null;

  let maxD = 0;
  for (const p of pts){
    maxD = Math.max(maxD, pointLineDist(p.x,p.y,a0.x,a0.y,a1.x,a1.y));
    if (maxD > FREE_LINE_MAX_DEVIATION) return null;
  }

  const st = {
    eraser:false,
    weight: pathAction.style.baseWeight || strokeWidth,
    color: pathAction.style.color || currentColor,
    alpha: pathAction.style.alpha ?? alphaFromTransp(transp)
  };

  return { type:"line", style: st, a:{x:a0.x,y:a0.y}, b:{x:a1.x,y:a1.y}, layer: pathAction.layer };
}

/* =====================
   Text overlay + MathJax v2 SVG
   ===================== */
function typesetTextOverlay(){
  if (!window.MathJax || !MathJax.Hub) return;
  MathJax.Hub.Queue(["Typeset", MathJax.Hub, textOverlay]);
}
function applyTextStyleToNode(node, style){
  node.style.fontFamily = '"Libertinus Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  if (style === "bold"){
    node.style.fontWeight = "700";
    node.style.fontStyle = "normal";
  } else if (style === "italic"){
    node.style.fontWeight = "400";
    node.style.fontStyle = "italic";
  } else {
    node.style.fontWeight = "400";
    node.style.fontStyle = "normal";
  }
}
function rebuildTextOverlay(){
  textOverlay.innerHTML = "";

  for (let li=0; li<3; li++){
    if (!layers[li].visible) continue;
    const actions = layers[li].actions;
    for (let i=0;i<actions.length;i++){
      const a = actions[i];
      if (a.type!=="text") continue;

      const div = document.createElement("div");
      div.className = "text-box";
      div.style.left = a.x + "px";
      div.style.top  = a.y + "px";
      div.style.fontSize = (a.size || 20) + "px";
      div.style.pointerEvents = (tool==="text" || tool==="pointer") ? "auto" : "none";

      applyTextStyleToNode(div, a.style || "regular");
      div.textContent = a.raw;

      div.dataset.layer = String(li);
      div.dataset.index = String(i);

      div.addEventListener("pointerdown",(ev)=>{
        if (tool==="text"){
          ev.stopPropagation();
          openTextEditor(a.x, a.y, a.raw, a.size, a.style, i, li);
        }
      });

      textOverlay.appendChild(div);
    }
  }

  setTimeout(()=>{
    typesetTextOverlay();
    if (window.MathJax && MathJax.Hub){
      MathJax.Hub.Queue(()=>{
        for (let li=0; li<3; li++){
          const nodes = textOverlay.querySelectorAll(`.text-box[data-layer="${li}"]`);
          nodes.forEach(node=>{
            const idx = parseInt(node.dataset.index,10);
            const act = layers[li].actions[idx];
            if (act && act.type==="text"){
              act.w = node.offsetWidth;
              act.h = node.offsetHeight;
            }
          });
        }
      });
    }
  }, 0);
}

function openTextEditor(x,y,raw,size,style,actionIndex, layerIndex){
  const li = (typeof layerIndex === "number") ? layerIndex : activeLayer;

  const s = size || defaultTextSize || 20;
  defaultTextSize = s;
  textSizeEditor.value = String(s);

  const st = style || defaultTextStyle || "regular";
  defaultTextStyle = st;
  textStyleEditor.value = st;

  textDraft={ layer:li, actionIndex, x,y, raw, size:s, style:st };
  textEditor.style.display="block";
  textInput.value = raw || "";

  const pad=10, ew=420, eh=220;
  let left = clamp(x+pad, 8, window.innerWidth-ew-8);
  let top  = clamp(y+pad, 8, window.innerHeight-eh-8);
  textEditor.style.left = `${left}px`;
  textEditor.style.top  = `${top}px`;

  setTimeout(()=>textInput.focus(),0);
}
textSizeEditor.addEventListener("change", ()=>{
  const s = parseInt(textSizeEditor.value,10);
  defaultTextSize = s;
  if (textDraft) textDraft.size = s;
});
textStyleEditor.addEventListener("change", ()=>{
  const st = textStyleEditor.value;
  defaultTextStyle = st;
  if (textDraft) textDraft.style = st;
});
function cancelTextEdit(){ textEditor.style.display="none"; textDraft=null; }
function commitTextEdit(){
  if (!textDraft){ textEditor.style.display="none"; return; }
  const raw = (textInput.value||"").trim();
  const L = layers[textDraft.layer];
  if (!raw){ cancelTextEdit(); return; }

  pushUndo(textDraft.layer);

  const action = {
    type:"text",
    x:textDraft.x, y:textDraft.y,
    raw,
    size:textDraft.size || defaultTextSize,
    style:textDraft.style || defaultTextStyle,
    w:null, h:null
  };

  if (textDraft.actionIndex==null) L.actions.push(action);
  else L.actions[textDraft.actionIndex] = action;

  cancelTextEdit();
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   Pointer routing
   ===================== */
function closePopups(){
  palette.classList.remove("open");
  layersMenu.classList.remove("open");
}
function isPointerOverUIClient(cx,cy){
  const r = ui.getBoundingClientRect();
  return cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom;
}
function pointerToCanvasXY(ev){
  const rect = ev.target.getBoundingClientRect();
  return { x: ev.clientX-rect.left, y: ev.clientY-rect.top };
}

/* =====================
   Start / extend / finish action
   ===================== */
function startAction(x,y,pressure,pointerType){
  closePopups();
  clearHoldAlignTimer();
  lastSignificantMoveAt = performance.now();
  lastMovePos = {x,y};

  if (tool==="pointer") return;

  if (tool==="text"){
    clearSelection();
    openTextEditor(x,y,"",defaultTextSize,defaultTextStyle,null,activeLayer);
    return;
  }

  if (tool==="fill"){
    clearSelection();
    pushUndo(activeLayer);
    const a = alphaFromTransp(transp);
    const ok = floodFillOnLayer(activeLayer, x, y, currentColor, a);
    if (ok){
      layers[activeLayer].actions.push({type:"fill", x, y, color: currentColor, alpha: a});
      rebuildTextOverlay();
      saveToStorage(slideKey);
    }
    return;
  }

  if (tool==="lasso"){
    if (lasso.selectedIdx.length && pointInBBox(x,y,lasso.bbox)){
      pushUndo(activeLayer);
      lasso.mode="move";
      lasso.moveStart={x,y};
      return;
    }
    clearSelection();
    lasso.selecting=true;
    lasso.points=[{x,y}];
    return;
  }

  if (tool==="laser"){
    const p0=snapPoint(x,y);
    laserTrail.push({x:p0.x,y:p0.y,t:millis()});
    current={type:"laser"};
    return;
  }

  clearSelection();

  const p0=snapPoint(x,y);
  const layerIndex=activeLayer;

  if (tool==="highlighter"){
    strokeWidth = 20;
    transp = 7;
    strokeWidthSel.value = String(strokeWidth);
    transpSel.value = String(transp);
    updateStrokeSelectLabel();
    updateTranspSelectLabel();

    pushUndo(layerIndex);
    const alpha = alphaFromTransp(transp);
    current={ type:"line", style:{ eraser:false, weight:strokeWidth, color:"#FFFF00", alpha }, a:p0, b:p0, layer:layerIndex };
    return;
  }

  if (tool==="pen" || tool==="eraser"){
    pushUndo(layerIndex);
    const style=makeStyleForCurrent(pressure,pointerType);
    current = { type:"path", style:{...style, weight:undefined}, points:[{x:p0.x,y:p0.y,p:pressure||1}], layer:layerIndex, pointerType };
    return;
  }

  if (["line","arrow","circle","rect","ellipse"].includes(tool)) pushUndo(layerIndex);

  const style=makeStyleForCurrent(pressure,pointerType);
  if (tool==="line") current={type:"line", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="arrow") current={type:"arrow", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="circle") current={type:"circle", style:style, c:p0, r:0, layer:layerIndex};
  if (tool==="rect") current={type:"rect", style:style, a:p0, b:p0, layer:layerIndex};
  if (tool==="ellipse") current={type:"ellipse", style:style, a:p0, b:p0, layer:layerIndex};
}

function extendAction(x,y,pressure,pointerType){
  if (tool==="lasso"){
    if (lasso.mode==="move" && lasso.moveStart){
      const dx = x - lasso.moveStart.x;
      const dy = y - lasso.moveStart.y;
      const L = layers[activeLayer];
      for(const idx of lasso.selectedIdx) translateAction(L.actions[idx], dx, dy);
      lasso.moveStart = {x,y};
      recomputeSelectionBBox();
      rebuildLayerBuffer(activeLayer);
      rebuildTextOverlay();
      return;
    }
    if (lasso.selecting){
      const last=lasso.points[lasso.points.length-1];
      if (dist(last.x,last.y,x,y)<2) return;
      lasso.points.push({x,y});
      return;
    }
    return;
  }

  if (!current) return;

  const p = snapPoint(x,y);

  if (current.type==="laser"){
    laserTrail.push({x:p.x,y:p.y,t:millis()});
    return;
  }

  const now = performance.now();
  const still = isStill(now, p.x, p.y);
  if (still && !holdAlignTimer) armHoldAlignTimer();

  if (current.type==="line" || current.type==="arrow"){
    current.b = p;
    if (isShiftDown){
      maybeAlignLineLike(current);
      clearHoldAlignTimer();
    }
    return;
  }

  if (current.type==="path"){
    const pts=current.points;
    const last=pts[pts.length-1];
    if (dist(last.x,last.y,p.x,p.y) < 0.8) return;

    const sm = current.style.smoothing || 1;
    const a = (sm<=1)?1:(2/(sm+1));
    const nx = last.x + a*(p.x-last.x);
    const ny = last.y + a*(p.y-last.y);
    pts.push({x:nx,y:ny,p:(pressure ?? 1)});
    return;
  }

  if (["rect","ellipse"].includes(current.type)) current.b = p;
  if (current.type==="circle") current.r = dist(current.c.x,current.c.y,p.x,p.y);
}

function finishAction(){
  clearHoldAlignTimer();

  if (tool==="lasso"){
    if (lasso.mode==="move"){
      lasso.mode="idle";
      lasso.moveStart=null;
      rebuildLayerBuffer(activeLayer);
      rebuildTextOverlay();
      saveToStorage(slideKey);
      return;
    }
    if (lasso.selecting){
      lasso.selecting=false;
      lassoSelect();
      return;
    }
    return;
  }

  if (!current) return;
  if (current.type==="laser"){ current=null; return; }

  const L=layers[current.layer];

  if (current.type==="path"){
    L.actions.push({ type:"path", style: current.style, points: current.points });

    const a = L.actions[L.actions.length-1];
    const pts=a.points;
    for (let k=1;k<pts.length;k++){
      const p0=pts[k-1], p1=pts[k];
      const avgP=((p0.p??1)+(p1.p??1))/2;
      const mult=pressureMultiplier(avgP, "pen");
      const w=(a.style.baseWeight||2)*mult;

      if (a.style.eraser){
        L.pg.erase();
        L.pg.stroke(0); L.pg.strokeWeight(w);
        L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
        L.pg.line(p0.x,p0.y,p1.x,p1.y);
        L.pg.noErase();
      } else {
        const col=color(a.style.color); col.setAlpha(a.style.alpha??255);
        L.pg.stroke(col); L.pg.strokeWeight(w);
        L.pg.strokeCap(ROUND); L.pg.strokeJoin(ROUND);
        L.pg.line(p0.x,p0.y,p1.x,p1.y);
      }
    }
  } else {
    L.pg.push();
    drawShapeAction(current, L.pg);
    L.pg.pop();
    L.actions.push(current);
  }

  current=null;
  rebuildTextOverlay();
  saveToStorage(slideKey);
}

/* =====================
   Pointer events
   ===================== */
function onPointerDown(ev){
  ev.preventDefault();
  lastPointerClient = {x: ev.clientX, y: ev.clientY};

  if (textEditor.style.display!=="none" && !textEditor.contains(ev.target)) commitTextEdit();
  if (isPointerOverUIClient(ev.clientX, ev.clientY)) return;

  pointerDown=true;
  activePointerId=ev.pointerId;
  activePointerType=ev.pointerType||"mouse";
  lastPressure=(typeof ev.pressure==="number") ? ev.pressure : 1;

  const {x,y} = pointerToCanvasXY(ev);
  startAction(x,y,lastPressure,activePointerType);
}
function onPointerMove(ev){
  lastPointerClient = {x: ev.clientX, y: ev.clientY};
  if(!pointerDown || ev.pointerId!==activePointerId) return;
  ev.preventDefault();
  lastPressure=(typeof ev.pressure==="number") ? ev.pressure : lastPressure;
  const {x,y} = pointerToCanvasXY(ev);
  extendAction(x,y,lastPressure,activePointerType);
}
function onPointerUp(ev){
  lastPointerClient = {x: ev.clientX, y: ev.clientY};
  if(!pointerDown || ev.pointerId!==activePointerId) return;
  ev.preventDefault();
  finishAction();

  pointerDown=false;
  activePointerId=null;
  activePointerType="mouse";
  lastPressure=1;
}

/* =====================
   Keyboard shortcuts
   ===================== */
function onKeyDown(ev){
  if (ev.key === "Shift") isShiftDown = true;

  if (ev.key === "Escape"){
    if (textEditor.style.display!=="none") cancelTextEdit();
    clearSelection();
    setTool("pointer");
    return;
  }
  if (textEditor.style.display!=="none") return;

  const k = ev.key.toLowerCase();

  if (/^[1-9]$/.test(k)){
    const idx = parseInt(k,10) - 1;
    const vals=[1,2,3,4,5,8,10,20,30];
    const v = vals[idx] ?? vals[vals.length-1];
    strokeWidth = v;
    lastNonEraserWidth = v;
    strokeWidthSel.value = String(v);
    updateStrokeSelectLabel();
    penState = { color: currentColor, width: strokeWidth, transp, smoothing };
    return;
  }

  if (k==="p") setTool("pen");
  if (k==="e") setTool("eraser");
  if (k==="h") setTool("highlighter");
  if (k==="r") setTool("laser");
  if (k==="l") setTool("lasso");
  if (k==="t") setTool("text");
  if (k==="f") setTool("fill");

  if (k==="s"){
    shapeIndex = (shapeIndex + 1) % SHAPES.length;
    const sh = SHAPES[shapeIndex];
    setTool(sh);
    showCursorHint(`Shapes: ${sh}`);
  }

  if (k==="g"){
    bgMode = (bgMode==="transparent") ? "dots" : (bgMode==="dots") ? "grid" : "transparent";
    bgModeSel.value = bgMode;
    saveToStorage(slideKey);
  }

  if (k==="n"){
    snapToGrid = !snapToGrid;
    snapEl.checked = snapToGrid;
  }

  if ((ev.ctrlKey||ev.metaKey) && k==="z"){
    ev.preventDefault();
    undoActiveLayer();
  }

  if (lasso.selectedIdx.length && (ev.key==="Delete" || ev.key==="Backspace")){
    ev.preventDefault();
    deleteSelection();
  }
}

/* =====================
   UI
   ===================== */
let ui, dragHandle;
let btnCycle, glyphCycle;

let toolPenBtn, toolEraserBtn, toolLaserBtn, toolHighlighterBtn, toolTextBtn, toolFillBtn, toolLassoBtn, toolArrowBtn;
let bgModeSel, strokeWidthSel, smoothingSel, transpSel;
let snapEl, undoBtn, clearBtn;

let colorSelect, palette, paletteGrid, colorChip;
let layersSelect, layersMenu, layersLabel;

let collapseState = "partial";

function initUI(){
  ui=document.getElementById("ui");
  dragHandle=document.getElementById("dragHandle");

  btnCycle=document.getElementById("btnCycle");
  glyphCycle=document.getElementById("glyphCycle");

  toolPenBtn=document.getElementById("toolPen");
  toolEraserBtn=document.getElementById("toolEraser");
  toolHighlighterBtn=document.getElementById("toolHighlighter");
  toolArrowBtn=document.getElementById("toolArrow");
  toolFillBtn=document.getElementById("toolFill");
  toolTextBtn=document.getElementById("toolText");
  toolLaserBtn=document.getElementById("toolLaser");
  toolLassoBtn=document.getElementById("toolLasso");

  bgModeSel=document.getElementById("bgMode");
  strokeWidthSel=document.getElementById("strokeWidth");
  smoothingSel=document.getElementById("smoothing");
  transpSel=document.getElementById("transp");
  snapEl=document.getElementById("snap");

  colorSelect=document.getElementById("colorSelect");
  palette=document.getElementById("palette");
  paletteGrid=document.getElementById("paletteGrid");
  colorChip=document.getElementById("colorChip");

  layersSelect=document.getElementById("layersSelect");
  layersMenu=document.getElementById("layersMenu");
  layersLabel=document.getElementById("layersLabel");

  undoBtn=document.getElementById("undo");
  clearBtn=document.getElementById("clear");

  // palette
  paletteGrid.innerHTML="";
  COLORS.forEach(hex=>{
    const sw = document.createElement("div");
    sw.className="swatch";
    sw.style.background=hex;
    sw.addEventListener("pointerdown",(ev)=>{
      ev.stopPropagation();
      currentColor=hex;
      colorChip.style.background=hex;
      palette.classList.remove("open");
      penState = { color: currentColor, width: strokeWidth, transp, smoothing };
      saveToStorage(slideKey);
    });
    paletteGrid.appendChild(sw);
  });
  colorChip.style.background=currentColor;

  document.addEventListener("pointerdown",(ev)=>{
    if(!colorSelect.contains(ev.target)) palette.classList.remove("open");
    if(!layersSelect.contains(ev.target)) layersMenu.classList.remove("open");
  }, {capture:true});

  colorSelect.addEventListener("pointerdown",(ev)=>{
    ev.stopPropagation();
    layersMenu.classList.remove("open");
    palette.classList.toggle("open");
  });
  layersSelect.addEventListener("pointerdown",(ev)=>{
    ev.stopPropagation();
    palette.classList.remove("open");
    layersMenu.classList.toggle("open");
  });

  // collapse cycle
  btnCycle.addEventListener("click",(ev)=>{
    ev.stopPropagation();
    collapseState = (collapseState==="full") ? "partial" : (collapseState==="partial") ? "expanded" : "full";
    applyCollapseState();
  });
  function updateCycleGlyph(){
    glyphCycle.textContent = (collapseState==="expanded") ? "‚ñ¥" : "‚ñæ";
  }
  function applyCollapseState(){
    ui.classList.toggle("full", collapseState==="full");
    ui.classList.toggle("partial", collapseState==="partial");
    ui.classList.toggle("expanded", collapseState==="expanded");
    if (collapseState==="full") closePopups();
    updateCycleGlyph();
  }
  window.applyCollapseState = applyCollapseState;

  // tools
  toolPenBtn.addEventListener("click",()=> setTool("pen"));
  toolEraserBtn.addEventListener("click",()=> setTool("eraser"));
  toolHighlighterBtn.addEventListener("click",()=> setTool("highlighter"));
  toolArrowBtn.addEventListener("click",()=>{ shapeIndex = 1; setTool("arrow"); });
  toolFillBtn.addEventListener("click",()=> setTool("fill"));
  toolTextBtn.addEventListener("click",()=> setTool("text"));
  toolLaserBtn.addEventListener("click",()=> setTool("laser"));
  toolLassoBtn.addEventListener("click",()=> setTool("lasso"));

  bgModeSel.addEventListener("change",()=>{ bgMode=bgModeSel.value; saveToStorage(slideKey); });

  buildStrokeSelect();
  buildSmoothingSelect();
  buildTranspSelect();

  snapEl.checked=snapToGrid;
  snapEl.addEventListener("change",()=>{ snapToGrid=snapEl.checked; });

  undoBtn.addEventListener("click",()=>{ clearSelection(); undoActiveLayer(); });
  clearBtn.addEventListener("click",()=>{
    clearSelection();
    pushUndo(activeLayer);
    layers[activeLayer].actions = [];
    rebuildLayerBuffer(activeLayer);
    rebuildTextOverlay();
    saveToStorage(slideKey);
  });

  rebuildLayersMenu();
  updateLayersLabel();

  applyCollapseState();
  initDrag();

  document.getElementById("btnShortcuts").addEventListener("click",(e)=>e.preventDefault());

  // ‚Äúshapes‚Äù defaults to arrow button (no dropdown)
  setTool("arrow");
}

function buildStrokeSelect(){
  strokeWidthSel.innerHTML="";
  const vals=[1,2,3,4,5,8,10,20,30];
  for (const v of vals){
    const o=document.createElement("option");
    o.value=String(v);
    o.textContent = `${v} pt`;
    if (v===strokeWidth) o.selected=true;
    strokeWidthSel.appendChild(o);
  }
  updateStrokeSelectLabel();
  strokeWidthSel.addEventListener("change",()=>{
    strokeWidth=parseInt(strokeWidthSel.value,10);
    if(tool!=="eraser") lastNonEraserWidth=strokeWidth;
    updateStrokeSelectLabel();
    penState = { color: currentColor, width: strokeWidth, transp, smoothing };
  });
}
function updateStrokeSelectLabel(){
  const opt = strokeWidthSel.options[strokeWidthSel.selectedIndex];
  opt.textContent = `‚Üï Width ${strokeWidthSel.value} pt`;
  for (const o of strokeWidthSel.options){
    if (o !== opt) o.textContent = `${o.value} pt`;
  }
}
function buildSmoothingSelect(){
  smoothingSel.innerHTML="";
  for (let v=1; v<=10; v++){
    const o=document.createElement("option");
    o.value=String(v);
    o.textContent = `${v}`;
    if (v===smoothing) o.selected=true;
    smoothingSel.appendChild(o);
  }
  updateSmoothingSelectLabel();
  smoothingSel.addEventListener("change",()=>{
    smoothing=parseInt(smoothingSel.value,10);
    updateSmoothingSelectLabel();
    penState = { color: currentColor, width: strokeWidth, transp, smoothing };
  });
}
function updateSmoothingSelectLabel(){
  const opt = smoothingSel.options[smoothingSel.selectedIndex];
  opt.textContent = `‚âà Smooth. ${smoothingSel.value}/10`;
  for (const o of smoothingSel.options){
    if (o !== opt) o.textContent = `${o.value}`;
  }
}
function buildTranspSelect(){
  transpSel.innerHTML="";
  for (let v=1; v<=10; v++){
    const o=document.createElement("option");
    o.value=String(v);
    o.textContent = `${v}`;
    if (v===transp) o.selected=true;
    transpSel.appendChild(o);
  }
  updateTranspSelectLabel();
  transpSel.addEventListener("change",()=>{
    transp=parseInt(transpSel.value,10);
    updateTranspSelectLabel();
    penState = { color: currentColor, width: strokeWidth, transp, smoothing };
  });
}
function updateTranspSelectLabel(){
  const opt = transpSel.options[transpSel.selectedIndex];
  opt.textContent = `‚óå Transp. ${transpSel.value}/10`;
  for (const o of transpSel.options){
    if (o !== opt) o.textContent = `${o.value}`;
  }
}

function setTool(t){
  if(!t) t="pointer";
  if (textEditor.style.display!=="none") commitTextEdit();
  clearHoldAlignTimer();

  const isGoingToSpecial = (t==="highlighter" || t==="laser");
  if (isGoingToSpecial){
    penState = { color: currentColor, width: strokeWidth, transp, smoothing };
  }

  const isPenOrShape = (t==="pen" || ["line","arrow","circle","rect","ellipse"].includes(t));
  const fromSpecial = (tool==="highlighter" || tool==="laser");
  if (isPenOrShape && fromSpecial){
    currentColor = penState.color;
    strokeWidth  = penState.width;
    transp       = penState.transp;
    smoothing    = penState.smoothing;

    colorChip.style.background = currentColor;
    strokeWidthSel.value = String(strokeWidth);
    smoothingSel.value = String(smoothing);
    transpSel.value = String(transp);
    updateStrokeSelectLabel();
    updateSmoothingSelectLabel();
    updateTranspSelectLabel();
  }

  tool=t;
  current=null;

  toolPenBtn.classList.toggle("active", tool==="pen");
  toolEraserBtn.classList.toggle("active", tool==="eraser");
  toolHighlighterBtn.classList.toggle("active", tool==="highlighter");
  toolArrowBtn.classList.toggle("active", tool==="arrow");
  toolFillBtn.classList.toggle("active", tool==="fill");
  toolTextBtn.classList.toggle("active", tool==="text");
  toolLaserBtn.classList.toggle("active", tool==="laser");
  toolLassoBtn.classList.toggle("active", tool==="lasso");

  if (tool==="laser"){
    currentColor = "#D7263D";
    transp = 1;
    strokeWidth = 2;

    colorChip.style.background = currentColor;
    transpSel.value = String(transp);
    strokeWidthSel.value = String(strokeWidth);

    updateTranspSelectLabel();
    updateStrokeSelectLabel();
  }

  if (tool==="highlighter"){
    strokeWidth = 20;
    transp = 7;
    strokeWidthSel.value = String(strokeWidth);
    transpSel.value = String(transp);
    updateStrokeSelectLabel();
    updateTranspSelectLabel();
  }

  if (tool==="eraser"){
    lastNonEraserWidth = lastNonEraserWidth ?? strokeWidth;
    strokeWidth=10;
  } else if (tool!=="highlighter" && tool!=="laser") {
    strokeWidth=lastNonEraserWidth ?? strokeWidth ?? 2;
  }

  strokeWidthSel.value = String(strokeWidth);
  smoothingSel.value = String(smoothing);
  transpSel.value = String(transp);
  updateStrokeSelectLabel();
  updateSmoothingSelectLabel();
  updateTranspSelectLabel();

  const boxes = textOverlay.querySelectorAll(".text-box");
  boxes.forEach(b=> b.style.pointerEvents = (tool==="text") ? "auto" : "none");

  rebuildTextOverlay();
}

/* draggable toolbar */
function initDrag(){
  let dragging=false, startX=0,startY=0,startLeft=0,startTop=0;

  dragHandle.addEventListener("pointerdown",(ev)=>{
    if (ev.target.closest("button")) return;
    dragging=true;
    dragHandle.setPointerCapture(ev.pointerId);
    startX=ev.clientX; startY=ev.clientY;
    const rect=ui.getBoundingClientRect();
    startLeft=rect.left; startTop=rect.top;
    ui.style.left=`${startLeft}px`;
    ui.style.top=`${startTop}px`;
    ui.style.right="auto";
  });

  dragHandle.addEventListener("pointermove",(ev)=>{
    if(!dragging) return;
    const dx=ev.clientX-startX, dy=ev.clientY-startY;
    const rect=ui.getBoundingClientRect();
    const w=rect.width, h=rect.height;
    let nl=clamp(startLeft+dx, 8, window.innerWidth-w-8);
    let nt=clamp(startTop+dy, 8, window.innerHeight-h-8);
    ui.style.left=`${nl}px`;
    ui.style.top=`${nt}px`;
  });

  dragHandle.addEventListener("pointerup",()=>{ dragging=false; });
}

/* layers menu */
function rebuildLayersMenu(){
  layersMenu.innerHTML="";
  for (let i=0;i<3;i++){
    const item=document.createElement("div");
    item.className="layer-item" + (layers[i].visible ? "" : " invisible");

    const left=document.createElement("div");
    left.className="layer-left";

    const tick=document.createElement("div");
    tick.className="tick";
    tick.textContent=(i===activeLayer)?"‚úì":"";

    const visDot=document.createElement("div");
    visDot.className="vis-dot";

    const name=document.createElement("div");
    name.className="layer-name";
    name.textContent=`Layer ${i+1}`;

    left.appendChild(tick);
    left.appendChild(visDot);
    left.appendChild(name);

    const right=document.createElement("div");
    right.style.fontSize="12px";
    right.style.opacity="0.65";
    right.textContent=layers[i].visible ? "on" : "off";

    item.appendChild(left);
    item.appendChild(right);

    item.addEventListener("pointerdown",(ev)=>{
      ev.stopPropagation();
      if (activeLayer!==i) activeLayer=i;
      else layers[i].visible = !layers[i].visible;

      clearSelection();
      updateLayersLabel();
      rebuildLayersMenu();
      layersMenu.classList.remove("open");
      rebuildAllBuffers();
      rebuildTextOverlay();
      saveToStorage(slideKey);
    });

    layersMenu.appendChild(item);
  }
}
function updateLayersLabel(){
  const vis = layers[activeLayer]?.visible ? "on" : "off";
  layersLabel.textContent = `üß±  Layers (${activeLayer+1}:${vis})`;
}
</script>
</body>
</html>
